var tipuesearch = {"pages": [{'title': 'About', 'text': '課程名稱: Introduction to Computer Programming (計算機程式) \n Github 倉儲:  https://github.com/mdecycu/cp2025 \n 課程網頁:  https://mde.tw/cp2025 \n 可攜程式套件: \n portable_2026.7z \xa0(387MB) \n 解開壓縮後，雙點擊\xa0start_miniconda3.bat 啟動可攜系統，雙點擊 stop.bat 關閉可攜系統。 \n 可攜系統啟動後，在命令列執行 conda activate y:\\envs\\cmsimde 可進入能執行 CMSiMDE 的環境。 \n 若希望可攜系統啟動直接進入 cmsimde 環境，可將 start_miniconda3.bat 檔案中第 98 行: call "%CONDA_ROOT%\\Scripts\\activate.bat" %ENV_NAME% 更換為 call "%CONDA_ROOT%\\Scripts\\activate.bat" %Disk%:\\envs\\cmsimde。 \n 課程內容: \n 如何維持教室整齊清潔? \n 學員定期打掃 (由助教安排)\xa0 \n 學員自律 \n 如何善用教室與工作站室硬體? \n 電腦設定 \n 網路連線 \n 課餘時間預約\xa0(由助教安排)\xa0 \n Python 與 Javascript 程式語法在  Reeborg  機器人系統上的應用。 \n Python 程式教材 \n 利用 Git 與 Github 建立分組網站。 \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入 \xa0 https://login.microsoftonline.com/ \xa0 Office 365 \n MS Teams 團隊代碼:\xa0w87x8do \xa0 \n 課程評分: \n 作業報告 (60%)  - MS Teams 線上參與，6人一組每三週發表學習心得。 \n w3、w7、w10、w14、w17、w18 \n 個人與分組網站維護 (40%)  - 每週至少兩次推送與課程進度相關的學習內容與心得。 \n w9 期中自評、w18 期末自評 \n 行事曆 \n 1a 上課時段: 每週三 13:20 - 16:10 \n 1b 上課時段: 每週四 09:10 - 12:00 (w17 1/1 放假) \n  全頁檢視  \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'talk', 'text': "Title: Opportunities and Challenges of Mechanical Design Engineering in the AI Era Introduction \n Ladies and gentlemen, esteemed colleagues, and distinguished guests, \n It’s an honor to stand before you today to discuss a subject that is both deeply relevant and highly exciting in the world of engineering: the opportunities and challenges of mechanical design engineering in the AI era. We are living in a transformative period—one where artificial intelligence is not just an abstract concept but a driving force in shaping industries, workflows, and how we think about design and innovation. The impact of AI on mechanical engineering is profound, creating new possibilities while also presenting significant challenges. In the next 30 minutes, I will explore how AI is revolutionizing mechanical design, examine the opportunities it brings, delve into the challenges engineers must overcome, and share some thoughts on how we can best navigate this era of change. \n 1. The Role of AI in Mechanical Design \n To begin, let’s take a closer look at how AI is changing the landscape of mechanical design engineering. Traditionally, mechanical design has been a process driven by human intuition, manual calculations, and trial-and-error experimentation. Engineers would design structures, systems, or products, often relying on experience and expertise to solve complex problems. However, with the advent of AI and machine learning, this process has undergone a dramatic shift. AI tools now allow engineers to analyze vast datasets in real-time, identify patterns that are too complex for the human mind, and optimize designs in ways that were previously unimaginable. With the power of deep learning algorithms, AI can generate optimized solutions that minimize material waste, reduce energy consumption, and improve overall performance. One of the most exciting areas of AI in mechanical design is generative design. In generative design, engineers input specific parameters—such as material type, manufacturing methods, and cost constraints—and the AI system generates a multitude of design options, each optimized for performance and efficiency. This approach can lead to lighter, stronger, and more cost-effective products, especially in industries like aerospace, automotive, and robotics. For example, in the aerospace industry, AI-powered design systems have enabled the creation of lightweight, yet incredibly strong structures, improving fuel efficiency and reducing manufacturing costs. In automotive design, AI has helped engineers create safer, more energy-efficient vehicles by optimizing every component, from chassis design to aerodynamics. Another area where AI is making an impact is simulation and testing. Traditional methods of physical prototyping are time-consuming and costly. With AI-based simulations, engineers can predict how a product will behave under various real-world conditions before it is ever built. This not only speeds up the design process but also reduces the risk of failure during testing, ultimately saving both time and money. 2. Opportunities Brought by AI \n Now, let's delve into the specific opportunities that AI presents to mechanical design engineers. A. Enhanced Efficiency and Productivity \n AI can significantly enhance productivity by automating repetitive tasks and optimizing workflows. With AI tools handling the more mundane aspects of design, engineers have more time to focus on higher-level, creative problem-solving. The ability to automate tasks like material selection, load calculations, and even aesthetic design elements allows for faster iterations and more efficient design processes. B. Improved Precision and Accuracy \n Another opportunity that AI brings is the ability to achieve much higher levels of precision and accuracy. In traditional mechanical design, even minor errors in calculations or measurements can have significant consequences, particularly in high-stakes industries like aerospace and medical devices. AI can perform complex calculations with precision and speed, significantly reducing the margin for error and ensuring that designs meet stringent safety and performance standards. C. Innovation and Creativity \n Perhaps one of the most exciting opportunities AI offers is the potential to foster innovation and creativity. By taking over routine tasks, AI allows engineers to focus on the more imaginative and forward-thinking aspects of design. In a way, AI can act as a creative partner, offering new solutions and perspectives that might not have been considered otherwise. For instance, AI-powered tools can identify overlooked design possibilities or propose entirely new materials or methods of construction. These innovations could lead to breakthrough products that solve global challenges, such as sustainable energy solutions, eco-friendly materials, and more efficient transportation systems. D. Integration with Advanced Manufacturing Techniques \n AI also opens up new opportunities in the integration of additive manufacturing or 3D printing in mechanical design. With AI, engineers can design structures that are optimized for 3D printing, creating highly complex geometries that would be impossible or impractical using traditional methods. This allows for more flexibility in design and a reduction in waste, which is essential in the pursuit of more sustainable manufacturing practices. 3. Challenges in the AI Era \n While the opportunities AI presents are vast, they are not without their challenges. Let’s now look at some of the key obstacles engineers face when working in the AI era. A. The Need for New Skills \n One of the most significant challenges is the need for engineers to acquire new skills. As AI takes over more routine, repetitive tasks, the role of the mechanical engineer is shifting. Engineers must now focus on creative problem-solving, strategic thinking, and collaboration. The rise of AI in design means that mechanical engineers must embrace new technologies, learn to work with AI systems, and understand how these tools can complement human expertise. This shift also calls for a rethinking of education and training. Engineering curriculums will need to adapt to incorporate AI, machine learning, and data analytics as core competencies. Continuing education and upskilling will be essential for engineers to remain competitive in the workforce. B. Data Quality and Security \n As engineers rely more on AI, data becomes the lifeblood of the design process. AI systems require vast amounts of data to train their models, and the quality of this data directly impacts the effectiveness of the AI system. Ensuring the accuracy, completeness, and security of data is a major concern. Sensitive data—especially in industries like healthcare, defense, and automotive—needs to be protected from breaches, and intellectual property must be safeguarded to avoid legal issues. C. Ethical and Legal Concerns \n As AI systems begin to make decisions in the design process, there are growing ethical concerns. For example, who is responsible if an AI-designed product fails or causes harm? How do we ensure that AI systems are free from bias and that they make decisions that are in the best interest of society? These questions require careful consideration, and engineers, policymakers, and ethicists must work together to establish clear guidelines and regulations. D. Job Displacement and Workforce Transition \n The increasing automation of tasks traditionally performed by engineers also raises concerns about job displacement. While AI has the potential to augment human capabilities, there is a fear that it could lead to the loss of jobs, particularly in areas of design, testing, and manufacturing. It is crucial for governments and companies to address these concerns by promoting policies that support retraining, reskilling, and a smooth transition into new roles that require higher-level skills. 4. Navigating the Challenges and Embracing AI \n So, how can we, as mechanical engineers, navigate these challenges and capitalize on the opportunities AI presents? A. Embrace Lifelong Learning \n The first step is to embrace lifelong learning. Engineers must stay informed about the latest AI developments and actively seek out training opportunities that will enhance their skill set. Companies should invest in professional development programs to help employees adapt to this changing landscape. B. Foster Collaboration Between Disciplines \n Another key to success is collaboration. Engineers, AI experts, and data scientists must work together to ensure that AI systems are being used effectively and ethically. By combining the strengths of both human and machine intelligence, we can create solutions that are not only more efficient but also more innovative. C. AI as a Tool, Not a Replacement \n Lastly, it’s important to view AI not as a replacement for human engineers but as a powerful tool that can enhance our capabilities. AI should be seen as a partner in the design process, capable of handling tasks that are repetitive and data-driven while leaving engineers free to focus on the creative, strategic, and high-level decision-making aspects of their work. 5. Conclusion \n In conclusion, we stand at the threshold of a new era in mechanical design engineering—one where AI opens up exciting new possibilities, enhances efficiency, and drives innovation. At the same time, it presents challenges that require us to evolve, adapt, and continue learning. The opportunities are immense, but so are the challenges. By embracing new skills, fostering collaboration, and integrating AI as a tool rather than a replacement, we can create a future where human ingenuity and artificial intelligence work hand-in-hand to solve some of the world’s most pressing problems. Thank you. \n 標題：AI時代下機械設計工程的機遇與挑戰 引言 各位女士、先生，親愛的同仁與尊敬的來賓： 今天能在這裡與各位探討一個在工程界既具高度相關性又令人振奮的議題，我感到無比榮幸——那就是「AI時代下機械設計工程的機遇與挑戰」。 我們正身處一個轉型的時代——人工智慧不再只是抽象的概念，而是實質上正在重塑各行各業、工作流程，乃至我們對設計與創新的思維方式。AI對機械工程的影響是深遠的，它帶來了前所未有的可能性，也伴隨著不少重大挑戰。 接下來的30分鐘，我將與各位一同探討AI如何徹底改變機械設計領域，分析它所帶來的機遇，深入剖析工程師們面臨的挑戰，並分享我對於如何迎接這場變革的思考。 一、AI在機械設計中的角色 首先，讓我們深入了解AI是如何重塑機械設計工程的格局。 傳統上，機械設計主要仰賴工程師的直覺、手動計算與反覆試驗。工程師依靠經驗與專業知識來解決複雜問題。然而，隨著AI與機器學習的興起，這一流程已經歷了翻天覆地的變化。 AI工具如今能夠即時分析龐大的數據集，識別出人類難以察覺的複雜模式，並以前所未有的方式優化設計。借助深度學習演算法，AI可以提出在材料使用、能源消耗與整體效能方面皆經過優化的解決方案。 AI在機械設計中最令人振奮的應用之一是「生成式設計」。在這種方法中，工程師輸入特定參數——例如材料種類、製造方法與成本限制——AI系統隨即產出多種設計選項，且每一種都針對性能與效率進行最佳化。這種方法能夠帶來更輕、更強、更具成本效益的產品，特別是在航太、汽車與機器人等產業。 例如，在航太產業中，AI驅動的設計系統讓我們能夠打造出既輕盈又堅固的結構，不僅提升燃油效率，還能降低製造成本。而在汽車設計領域，AI則幫助工程師優化從底盤到空氣動力學的每一個零組件，打造更安全、更節能的車輛。 AI的另一大應用是模擬與測試。傳統的物理原型測試既耗時又昂貴。利用AI模擬，工程師可在產品實體打造前預測其在各種實際條件下的表現，不僅加快設計流程，也大幅減少測試失敗風險，最終節省時間與成本。 二、AI帶來的機遇 接下來，我們深入探討AI為機械設計工程師帶來的幾項重要機遇。 A. 提升效率與生產力 AI能自動化重複性工作並優化工作流程，大幅提升設計效率。讓AI處理材料選擇、荷重計算、甚至美學設計等例行任務，工程師就能將更多時間投入在創意與策略思考上，加快設計迭代與開發進度。 B. 提高精度與準確性 AI帶來的另一項優勢是超高精準度。在傳統設計中，哪怕是微小的計算錯誤，也可能導致嚴重後果。AI能以極高的速度與精度完成複雜運算，降低錯誤率，確保產品符合嚴格的安全與性能標準。 C. 激發創新與創意 AI最吸引人的特點之一，是它能釋放工程師的創造力。AI接手例行工作後，工程師得以專注於構思創新設計與未來發展方向。AI甚至能充當創意夥伴，提出人類未曾想過的新材料、新構造與設計概念。 舉例來說，AI可能指出過去被忽略的設計可能性，或建議全新製造方式，促成突破性的產品問世，如綠色能源、永續材料及更高效的運輸系統。 D. 與先進製造技術整合 AI亦促進機械設計與先進製造技術（如3D列印）的融合。透過AI設計出專為3D列印優化的複雜結構，能實現傳統製造無法完成的幾何造型，減少材料浪費，提高設計彈性，並邁向更永續的製造方式。 三、AI時代的挑戰 儘管AI為我們帶來了諸多契機，但同時也伴隨不少挑戰。以下是幾項機械設計工程師在AI時代中面臨的主要難題： A. 技能更新的迫切性 隨著AI接管更多重複性任務，工程師的角色將轉向創意解決問題、戰略思考與跨領域合作。這代表工程師必須學習如何與AI系統協作，掌握AI、機器學習與數據分析的知識。 這也要求我們重新檢視教育體系與工程課程的設計，將AI等技術納入核心課程。終身學習與在職進修將成為工程師持續競爭的關鍵。 B. 數據品質與安全問題 AI系統仰賴龐大的高品質數據，資料的準確性、完整性與安全性攸關AI效能。在如醫療、國防、汽車等產業，敏感數據需高度保護，並確保智慧財產權不被侵犯，否則將引發法律與商業風險。 C. 倫理與法律議題 當AI在設計中逐漸具備決策能力時，相關的倫理與責任問題亦日益受到關注。例如：若AI設計的產品出現故障或造成損害，誰應負責？如何確保AI決策不帶偏見？工程師與政策制定者、倫理學者必須共同制定明確的法律與道德準則。 D. 就業衝擊與轉型壓力 AI自動化可能取代某些傳統職能，引發對失業的擔憂。雖然AI能增強人類能力，但對設計、測試與製造相關職位的影響不可忽視。因此，政府與企業必須積極推動職能轉型、技能再培訓計畫，協助勞工順利過渡至更高層次的職位。 四、應對挑戰，擁抱AI 那麼，身為機械工程師，我們該如何因應這些挑戰，並善用AI帶來的機遇呢？ A. 擁抱終身學習 工程師必須持續更新知識，主動參與AI技術的培訓課程。企業亦應投資於員工的職能提升，幫助團隊適應變化。 B. 推動跨領域合作 工程師應與AI專家、資料科學家緊密合作，確保AI系統的應用兼顧效率與倫理。透過人機協同，我們能打造更具創新力與競爭力的解決方案。 C. 將AI視為工具，而非取代者 我們應將AI視為設計過程中的強大助手——它可以處理重複性與數據密集的工作，讓工程師專注於策略性與創造性的決策。AI的價值，在於擴展人類能力，而非取而代之。 五、結語 總結來說，我們正站在機械設計工程全新時代的門檻上——AI不僅提升效率，還帶來創新機會。然而，我們也必須面對隨之而來的種種挑戰。 只要我們勇於學習新技術、推動跨界合作，並將AI作為賦能工具而非威脅，那麼人類的創造力與人工智慧將能攜手合作，共同解決全球最嚴峻的問題。 謝謝大家。 \n \n AI 世代企業中更具優勢的員工: \n 1. 具備 AI 技術能力或應用能力者: AI 轉型已成為各企業的核心策略，能夠設計、建構、或指導 AI 系統的員工，未來在組織架構中將具有較高價值。 \n 2. 具備跨部門創新及組織影響力者: 具備推動協同運作與組織創新的團隊成員，以及具備跨部門溝通能力與影響力的員工，將更容易被視為公司或部門 AI 轉型核心力量。 \n 3. 具備成長思維者: 能在動盪中快速學習與自我調整的員工，不只擁有一套技能，且能透過變通，協助公司或部門成長的員工，未來將更具優勢。 \n 4. 安全與品質領域的專業者: 專注在資訊安全、品質保證、或能協助落實 AI 專案執行的技術人員，在公司或部門中的地位將相對穩固。 \n", 'tags': '', 'url': 'talk.html'}, {'title': 'cs101', 'text': 'https://github.com/jackfrued/Python-Core-50-Courses \xa0(簡體中文) \n https://github.com/mdecycu/python_2025 \xa0(第1 ~ 19 課繁體中文) \n 最受歡迎的程式課 \n https://cs61a.org/ \xa0 \n https://www.composingprograms.com/ \xa0( composing_programs.pdf , 2019 version,  簡體中文翻譯 ) \n https://mde.tw/cs101 \xa0 \n', 'tags': '', 'url': 'cs101.html'}, {'title': 'Computer', 'text': '一、假如使用 Windows 操作系統 \n 顯示副檔名與隱藏檔 \n 檔案總管內定並無檢視副檔名與隱藏檔案的設定，若之後所使用的工具並非安裝版，其副檔名並未登錄於操作系統，因此可能無法透過檔案 icon 辨識檔案屬性，最直接的方式就是透過副檔名確認。 \n 其次，許多系統工具會使用 Windows 認定的隱藏檔格式 (以 . 開頭)，這些隱藏檔案或隱藏目錄，在 Git 指令操作時非常重要，因此建議將 Windows 檔案總管視窗下的檢視設定中，開啟檢視附檔名與隱藏檔的選項設定。 \n 假如使用 Windows 11 家用版 \n 家用版與專業版的差異: \n 家用版僅支援單一 CPU \n 家用版最多支援 128 GB 記憶體 \n 家用版無硬碟編碼功能 \n 家用版無  Windows Sandbox \n 家用版無 Remote Desk Top Host - 可以使用  VNC  進行遠端控制\xa0 \n 家用版必須自行安裝 Group Policy Editor (gpedit.msc) - 但可以 自行配置安裝 \n 家用版無 Hyper-V - 可以使用  Virtualbox  配置虛擬機 \n 無登入狀態使用 Windows 11 \n 新機開啟之後的設定流程，系統要求必須登入微軟帳號才能繼續使用時，可以透過指令輸入，在重新開機設定階段，繞過此一過程。 \n 意即，當按下 Shift + F10 (若有 Fn 鍵則需按下 Shift + Fn + F10) 時，系統會跳出命令列視窗，若此時命令列視窗中的目錄，已經跳到 C:\\Windows\\System32>，則可利用 cd OOBE 之後執行 BYPASSNRO，要求重新開機時繞過此一要求。 \n 這些指令都是英文字母，OOBE 是 Out Of Box Experience 的縮寫，而 BYPASSNRO 則是 BYPASS Network Requirement Out-of-box 的意思。 \n 在 Windows 11 設置過程，選擇執行\xa0C:\\Windows\\System32\\OOBE\\BYPASSNRO 按下 Enter，就會重新開機，之後的設置過程，便會繞過需要登入微軟帳號才能使用 Windows 11 的要求。 \n 自行安裝 gpedit.msc \n 另外，Windows 11 家用版並沒有 gpedit.msc 工具，這是操作系統的群組原則設置工具，若希望關閉微軟強制設定每 42 天必須重製密碼的內建原則，可以先安裝 gpedit.msc 之後再行修改。 \n 在搜尋欄位執行 cmd 之後，選擇以管理者身分啟動命令列視窗後，執行下列批次檔指令: \n get_gpedit.bat \n @echo off\npushd "%~dp0"\ndir /b %SystemRoot%\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum >Files.txt\ndir /b %SystemRoot%\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum >>Files.txt\nfor /f %%i in (\'findstr /i . Files.txt 2^>nul\') do dism /online /norestart /add-package:"%SystemRoot%\\servicing\\Packages\\%%i"\ndel Files.txt\npause\n \n 完成之後，可以在搜尋處輸入 gpedit.msc，開啟 Local Group Policy Editor，進入 Windows 設定 - 安全設定 - 帳戶原則 - 密碼原則中，若將密碼最長使用期限的 42 天改為 0，則密碼就可由使用者自行決定最長使用期限，不需要每 42 天被強迫更改。 \n 其他建議: \n 安裝  7zip 、安裝 Firefox，之後儘可能使用可攜套件。 \n 二、假如使用 Ubuntu \n Ubuntu  操作系統分為 Server 與 Desktop 版本，一般機械相關的課程所採用的套件大多僅支援 Windows 版，因此 Ubuntu 或其他 Linux 相關操作系統僅是用來建立輔助用的伺服器，或者用於測試所開發的套件是否能夠在 Ubuntu 環境中執行。 \n 在 Windows 11 操作系統中，利用  Virtualbox  配置一台 Ubuntu 虛擬機，應該是最方便的使用方式，儘管  Virtualbox  虛擬機僅能模擬大約 75% 的硬體效能，但只要 4GB Ram 與約 5GB 的硬碟空間就可以啟動，因此建議所使用的 Windows 筆電或桌機至少要有 32GB 的記憶體，以及 512 GB 以上的 SSD 硬碟空間. \n 三、假如使用 Mac \n MacOS  採用\xa0BSD 系列操作系統，屬於 UNiX，因此就機械相關課程的使用情況，與 Ubuntu 或其他 Linux 操作系統相似，大部分情況必須設法配置 Windows 11 虛擬機，或遠端登入到其他 Windows 11 機器，才能執行一些僅支援 Windows 的套件。\xa0\xa0 \n', 'tags': '', 'url': 'Computer.html'}, {'title': 'llama', 'text': '在自己的電腦上執行\xa0 llama : \n 若電腦有 GPU 可以加快運算，若只有 CPU 也可以執行，以下採一台安裝 Windows 10 的舊電腦進行示範。 \n 安裝 ollama 工具: \n 連線至  https://ollama.com ，下載安裝後，可直接執行 llama3.2 (約 2GB): \n 安裝完成後，ollama 位於:\xa0C:\\Users\\使用者帳號\\AppData\\Local\\Programs\\Ollama，可以利用命令列視窗或 Powershell 命令列視窗，更換目錄至 Ollama 之後，以 ollama list 列出已經取下的模型，例如: 系統已經取下 llama3.2，則可利用 ollama run llama3.2 執行。 \n 各種開放模擬列表:\xa0 https://ollama.com/search ，若要取下 deepseek-r1 模型 (約 5.2GB)： \n cd\xa0 C:\\Users\\使用者帳號\\AppData\\Local\\Programs\\Ollama \n ollama pull deepseek-r1 \n ollama run deepseek-r1 \n 若要中斷對談，使用 ctrl + c，若要跳出 ollama 的語言模型執行，使用 ctrl + d \n 以下畫面在電腦輔助設計室上一代電腦，配置 Intel i7-6700 CPU @ 3.40GHz，32GB 記憶體，安裝 NVIDIA GeForce GTX 950 顯卡電腦上執行: \n \n 有關 Llama (資料取自\xa0 llama ): \n Llama \xa0 ( Large Language Model Meta AI , formerly stylized as \xa0 LLaMA ) is a family of \xa0 large language models \xa0 (LLMs) released by \xa0 Meta AI \xa0 starting in February 2023. \xa0 The latest version is Llama 4, released in April 2025. \n Llama models come in different sizes, ranging from 1 billion to 2 trillion parameters. Initially only a \xa0 foundation model , \xa0 starting with Llama 2, Meta AI released instruction \xa0 fine-tuned \xa0 versions alongside foundation models. \n Model weights for the first version of Llama were only available to researchers on a case-by-case basis, under a non-commercial license. \xa0 Unauthorized copies of the first model were shared via \xa0 BitTorrent . \xa0 Subsequent versions of Llama were made accessible outside academia and released under licenses that permitted some commercial use. \n Alongside the release of Llama 3, \xa0 Meta \xa0 added \xa0 virtual assistant \xa0 features to  Facebook  and  WhatsApp \xa0in select regions, and a standalone website. Both services use a Llama 3 model. \n', 'tags': '', 'url': 'llama.html'}, {'title': 'nginx', 'text': '透過 ollama 與 nginx 的結合，在 Web based 介面中使用 llama: \n index.html \n <!DOCTYPE html>\n<html>\n<head>\n  <meta charset="UTF-8" />\n  <title>Ollama Chat</title>\n  <style>\n    body { font-family: sans-serif; margin: 2rem; max-width: 700px; }\n    textarea { width: 100%; height: 100px; }\n    pre { background: #eee; padding: 1em; white-space: pre-wrap; }\n  </style>\n</head>\n<body>\n  <h1>🧠 Chat with LLaMA (via Ollama)</h1>\n  <textarea id="prompt" placeholder="Say something..."></textarea><br/>\n  <button onclick="send()">Send</button>\n  <pre id="output"></pre>\n\n  <script>\n    async function send() {\n      const prompt = document.getElementById("prompt").value;\n      document.getElementById("output").textContent = "Thinking...";\n      const res = await fetch("/api/generate", {\n        method: "POST",\n        headers: { "Content-Type": "application/json" },\n        body: JSON.stringify({\n          model: "llama3",\n          prompt,\n          stream: false\n        })\n      });\n      const result = await res.json();\n      document.getElementById("output").textContent = result.response;\n    }\n  </script>\n</body>\n</html> \n nginx.conf 中對應的 server 設定: \n server {\n    listen 80;\n    server_name your.domain.com;\n\n    location / {\n        root /var/www/html;\n        index index.html;\n    }\n\n    location /api/ {\n        proxy_pass http://localhost:11434/;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n    }\n} \n 執行 ollama serve 或使用 ollama run 時，ollama 套件會在 http://localhost:11434 開啟一個 RESTful API 伺服器，讓你可以透過程式或前端介面與模型互動。 \n 因此執行 ollama run llama3.1:latest 之後，再伺服 nginx 的 index.html 後，就可以從 WWW 伺服器連接頁面上，與 llama 語言模型系統對話。 \n 若 ollama 所執行的模型支援 vision 功能，則可以進一步延伸 index.html，使用者可以上傳圖片與 AI 模型對話 \n index_vision.html \n <!DOCTYPE html>\n<html>\n<head>\n  <meta charset="UTF-8" />\n  <title>Ollama Chat + Image/File Upload</title>\n  <style>\n    body { font-family: sans-serif; max-width: 800px; margin: 2rem auto; }\n    textarea { width: 100%; height: 80px; }\n    .chatbox { white-space: pre-wrap; background: #f4f4f4; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; }\n    .file-label { margin-top: 0.5rem; display: block; font-weight: bold; }\n  </style>\n</head>\n<body>\n  <h2>🧠 Chat with LLaMA + Upload Image/Text</h2>\n  \n  <div class="chatbox" id="chatlog"></div>\n\n  <textarea id="prompt" placeholder="Say something..."></textarea><br>\n  \n  <label class="file-label">Upload image (.png/.jpg) or text (.txt/.md):</label>\n  <input type="file" id="fileInput" accept=".png,.jpg,.jpeg,.txt,.md"><br><br>\n  \n  <button onclick="send()">Send</button>\n\n  <script>\n    const chatlog = document.getElementById("chatlog");\n\n    async function send() {\n      const promptInput = document.getElementById("prompt").value.trim();\n      const fileInput = document.getElementById("fileInput");\n      if (!promptInput && fileInput.files.length === 0) return;\n\n      let userMessage = promptInput || "[No prompt]";\n      let fullPrompt = promptInput;\n\n      // 檔案處理\n      if (fileInput.files.length > 0) {\n        const file = fileInput.files[0];\n        const type = file.type;\n\n        if (type.startsWith("image/")) {\n          const base64 = await fileToBase64(file);\n          fullPrompt += `\\n\\n[以下為圖片 base64 編碼：]\\n${base64}`;\n        } else if (type === "text/plain" || file.name.endsWith(".md")) {\n          const text = await file.text();\n          fullPrompt += `\\n\\n[以下為文件內容：]\\n${text}`;\n        } else {\n          appendChat("❌ Unsupported file type.");\n          return;\n        }\n      }\n\n      appendChat("🧑\u200d💻 You:\\n" + userMessage);\n      appendChat("🤖 LLaMA is thinking...");\n\n      const res = await fetch("/api/generate", {\n        method: "POST",\n        headers: { "Content-Type": "application/json" },\n        body: JSON.stringify({\n          model: "llama3",\n          prompt: fullPrompt,\n          stream: false\n        })\n      });\n\n      const result = await res.json();\n      updateLastBotReply("🤖 LLaMA:\\n" + result.response);\n    }\n\n    function appendChat(text) {\n      const div = document.createElement("div");\n      div.className = "chatbox";\n      div.textContent = text;\n      chatlog.appendChild(div);\n      window.scrollTo(0, document.body.scrollHeight);\n    }\n\n    function updateLastBotReply(text) {\n      const boxes = document.getElementsByClassName("chatbox");\n      boxes[boxes.length - 1].textContent = text;\n    }\n\n    function fileToBase64(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result.split(",")[1]);\n        reader.onerror = reject;\n        reader.readAsDataURL(file);\n      });\n    }\n  </script>\n</body>\n</html> \n 或直接將 ollama 結合\xa0 https://www.openwebui.com/ \xa0提供 Web based 對話進階功能。 \n', 'tags': '', 'url': 'nginx.html'}, {'title': 'Homework', 'text': 'HW1: \n 請將程式碼存放在個人作業倉儲中的 python 目錄後，利用程式連結完成下列任務: \n around1 ,  around2 ,  around3 ,  around4 \n HW2: \n 請修改  Brython_robot  程式，讓機器人可以採水平巡邏方式，走過每一個區域。 \n 請修改  Brython_robot  程式，讓機器人可以採上下垂直巡邏方式，走過每一個區域。 \n 請修改 Pyodide  機器人自由行 程式，讓機器人可以採水平巡邏方式，走過每一個區域。 \n 請修改 Pyodide  機器人自由行2 程式，讓機器人可以採上下垂直巡邏方式，走過每一個區域。 \n HW3: \n 請修改  Brython_robot  程式，讓機器人可以與 機器人收割程式 的水平採收方式相同。 \n 請修改  Brython_robot  程式，讓機器人可以與 機器人收割程式 的上下垂直採收方式相同。 \n HW4: \n 請修改  Brython_robot  程式，讓機器人可以與 機器人收割程式 的採收與播種方式相同。 \n \n \n \n', 'tags': '', 'url': 'Homework.html'}, {'title': 'Topics', 'text': '電腦輔助設計室電腦硬體與網路使用介紹 \n C: 為 SSD，網路協定可以自行決定使用 IPv4 或 IPv6 (若使用純 IPv6 則必須設定 Proxy 才能連結到 github.com 以及僅支援 IPv4 協定的網站)\xa0 \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入 \xa0 https://login.microsoftonline.com/ \xa0 Office 365 \n Teams 團隊代碼: w87x8do \n 下載可攜程式套件: \n portable_2026.7z \xa0(387MB) \n 解開壓縮後，雙點擊\xa0start_miniconda3.bat 啟動可攜系統，雙點擊 stop.bat 關閉可攜系統。 \n 可攜系統啟動後，在命令列執行 conda activate y:\\envs\\cmsimde 可進入能執行 CMSiMDE 的環境。 \n 若希望可攜系統啟動直接進入 cmsimde 環境，可將 start_miniconda3.bat 檔案中第 98 行: call "%CONDA_ROOT%\\Scripts\\activate.bat" %ENV_NAME% 更換為 call "%CONDA_ROOT%\\Scripts\\activate.bat" %Disk%:\\envs\\cmsimde。 \n 各學員自行 建立 Github 帳號 \n 說明如何建立分組倉儲 Template \n 學習如何開啟可攜套件、關閉可攜套件 \n 利用 Python 執行設計運算及維護倉儲與網站內容 \n Windows  Batch file  與  Powershell  應用\xa0 \n Github Classroom  上的分組網站:  https://github.com/mdecp2025 \xa0 \n Github Classroom  是一套 Web based 工具，功能在於簡化採用 Github 倉儲進行教學與協同分組的工作\xa0 \n 各組組長建立  Github Classroom  分組團隊，各組取得分組倉儲\xa0 \n 學習如何在近端電腦與  Codespaces  上維護分組倉儲內容 \n 近端: Github Token 與 SSH (Putty、Registry ( 中文版 、 英文版 )應用)\xa0\xa0 \n 利用  Reeborg  學習 Python 基本語法 \n \n 計算機程式課程主題總覽 \n 課程簡介 \n 本課程以實作為導向，循序漸進學習  Python 、 JavaScript 、 HTML 、 CSS  等現代網頁與程式語言，最終應用於  Reeborg 機器人程式開發 。內容設計結合理論與實作，強調程式邏輯、問題解決與跨語言應用能力。 \n \n 從零基礎學習程式語言的基本結構與語法 \n 掌握網頁技術，為互動式機器人程式設計打下基礎 \n 專題實作，應用於 Reeborg’s World 機器人操作與挑戰任務 \n \n 課程主題與詳細內容 \n 1. Python 基礎與 Reeborg 機器人程式設計 \n \n Python 語言簡介：  特色、應用領域、開發環境介紹 \n 基本語法：  變數、資料型態、運算子、輸入與輸出 \n 流程控制：  條件判斷 ( if ,  elif ,  else )、迴圈 ( while ,  for ) \n 函式與模組：  函式定義與呼叫、自訂功能、模組導入 \n Reeborg’s World 操作： \n \n 基本指令 ( move() ,  turn_left() ,  take() ,  put() ) \n 感測器判斷 ( front_is_clear() ,  wall_in_front() ,  object_here() ,  at_goal() ) \n 將 Python 程式邏輯應用於控制機器人走迷宮、撿物、解任務 \n \n \n 實作練習：  關卡挑戰、流程規劃、錯誤偵錯與修正 \n \n 2. JavaScript 程式設計基礎 \n \n JavaScript 角色：  前端網頁互動語言，與 Python 差異與應用 \n 基本語法：  變數 ( let ,  const )、資料型態、運算子、輸出 ( console.log() ) \n 流程控制：  條件 ( if ,  else )、迴圈 ( for ,  while ) \n 函式與 ES6 新語法：  函式宣告、箭頭函式 ( () => {} ) \n 陣列與物件：  基本操作、方法應用 \n 與網頁互動：  認識 DOM、事件處理等（為後續進階鋪路） \n 小專題：  建立簡單計算機或互動網頁按鈕 \n \n 3. HTML 基礎 - 建構網頁內容 \n \n HTML 結構：  了解  <html> ,  <head> ,  <body>  等標籤 \n 常用標籤：   <h1>~<h6>  標題、 <p>  段落、 <a>  連結、 <img>  圖片、 <ul> / <ol>  列表、 <table>  表格 \n 表單與輸入：   <form> ,  <input> ,  <button>  等 \n 結構化分區：   <div> ,  <span> ,  <section> ,  <nav>  等 \n 專案實作：  製作個人簡歷網頁、Reeborg 世界說明頁等 \n \n 4. CSS 樣式設計 - 美化網頁版面 \n \n CSS 基本語法：  選擇器、屬性、值的語法結構 \n 常用樣式：  顏色 ( color 、 background )、字型 ( font-size 、 font-family )、邊框 ( border ), 間距 ( margin ,  padding ) \n 版面配置：   display 、 flex 、 grid  基礎 \n RWD 響應式設計：  讓你的網頁適合不同裝置 \n CSS 與 HTML 整合：  內嵌樣式、內部樣式表、外部 CSS 檔案 \n 美化 Reeborg 機器人專案網頁：  實作練習 \n \n 5. 綜合應用 - Reeborg 機器人專案開發 \n \n 專案規劃與團隊合作：  需求分析、分工合作 \n 跨語言整合：  利用 Python 控制邏輯、JavaScript 增強互動、HTML/CSS 展示結果 \n 打造專屬 Reeborg 世界：  設計自訂任務與挑戰 \n 成果展示：  發表與互評，分享學習心得 \n \n 學習建議與資源 \n \n 多加練習與嘗試，遇到困難主動討論與尋找資料 \n 推薦學習網站： Reeborg’s World 、 W3Schools 、 MDN Web Docs \n 建議每週規劃自主練習與小專案，培養實作與解決問題能力 \n 記錄學習歷程，定期回顧與修正 \n \n', 'tags': '', 'url': 'Topics.html'}, {'title': 'Git', 'text': '假如您還沒有 Github 帳號，請馬上 建立一個 。 \n 為何計算機程式課程要使用 Git 與 Github? \n 計算機程式課程（軟體開發）使用 Git 與 GitHub 主要有以下幾個原因： \n \n 版本控制: Git 是一套分散式的版本控制系統，能記錄每一個檔案的修改歷程。這樣就算不小心改壞了某一個版本的程式，也能隨時回復到以前的版本，而且在協同設計流程中，可以追蹤那一個使用者改了那些內容、什麼時候改的，可以快速釐清許多議題。 \n 團隊協作:\xa0多個開發者可以同時對同一個專案進行開發，透過分支（branch）機制，各自開發新功能、修 bug，最後再合併（merge）到主分支，避免互相覆蓋程式碼。 \n 雲端備份與分享:\xa0GitHub 是基於 Git 的雲端代管平台，可以將本地的 Git 專案上傳到雲端，不怕資料遺失。也方便將程式碼公開或私下分享給其他人。 \n 問題追蹤與管理:\xa0GitHub 除了儲存程式碼，還提供 issue、pull request 等工具，有助於追蹤 bug、討論功能、審查程式碼，提高專案管理效率。 \n 開放原始碼與社群合作:\xa0許多開放原始碼專案都放在 GitHub，任何人都能貢獻程式碼，促進社群協作與學習。 \n 總結：使用 Git 和 GitHub 可以讓程式開發更有組織、更安全、更容易協作與管理，也方便與他人分享、學習與成長。 \n \n 請舉實際的計算機程式開發案例，說明如何操作 Git 與 Github，以便取得程式開發流程的便利與優勢。 \n Git 與 GitHub 操作案例說明 \n Git 與 GitHub 實際操作案例：多人開發 ToDo List 網站 \n \n 1. 專案初始化與上傳 \n \n 步驟： \n \n 在本機建立專案資料夾，初始化 Git：\n git init \n \n 新增檔案（如  index.html 、 app.js ），並提交第一個版本：\n git add . git commit -m "Initial commit" \n \n 在 GitHub 建立新 repository，然後將本機專案推送到遠端：\n git remote add origin https://github.com/username/todo-app.git git push -u origin master \n \n \n 優勢：  所有程式碼都有歷史紀錄，且安全備份於雲端。 \n \n \n \n 2. 分支開發新功能 \n \n 情境： 小明負責開發「新增待辦事項」功能。 \n 步驟： \n \n 建立新分支：\n git checkout -b feature/add-todo-item \n \n 實作功能並提交：\n git add . git commit -m "Add feature to create todo item" \n \n 推送分支到 GitHub：\n git push origin feature/add-todo-item \n \n \n 優勢：  各自分支開發，互不干擾，降低衝突風險。 \n \n \n \n 3. Pull Request（合併請求）與 Code Review \n \n 情境： 小明開發完成，欲合併新功能到主分支。 \n 步驟： \n \n 在 GitHub 上建立 Pull Request，描述功能內容。 \n 其他團隊成員審查程式碼，提出建議或修正。 \n 經討論無誤後，管理員合併 PR。 \n \n 優勢：  強化程式品質與團隊溝通，每次合併都有討論紀錄。 \n \n \n \n 4. 處理 Bug 與 Issue 追蹤 \n \n 情境： 使用者發現「無法刪除待辦事項」的 bug。 \n 步驟： \n \n 在 GitHub issue 區提出 bug 報告。 \n 團隊分配成員修正，建立  fix/delete-todo-bug  分支。 \n 修正後提交、發 PR、review、合併。 \n \n 優勢：  所有 bug、功能需求有明確記錄，修正過程透明。 \n \n \n \n 5. 版本回溯與復原 \n \n 情境： 新功能導致主分支出錯。 \n 步驟： \n \n 透過 Git log 查找歷史版本：\n git log \n \n 回復到上一個穩定版本：\n git checkout <commit-id> \n \n \n 優勢：  不怕程式「改壞」，可隨時回復，輕鬆追蹤誰做了什麼修改。 \n \n \n \n 總結 \n Git 與 GitHub 提供完整的版本控制、團隊協作、問題追蹤、程式碼審查與備份機制，讓開發流程更有條理，大幅提升開發效率與品質。不論團隊或個人開發，都能享有回溯、備份、管理等多重好處。 \n \n', 'tags': '', 'url': 'Git.html'}, {'title': 'Git_ex1', 'text': 'Reeborg 機器人 Python 開發流程與 Git/GitHub 協作範例 \n 階段一：基礎 Python 與 Reeborg 指令 \n 初學者可直接用 Python 撰寫簡單的  Reeborg 機器人程式 ，例如讓機器人向前走數步、左轉、撿物件： \n move()\nmove()\nturn_left()\nmove()\nif object_here():\n    take()\n \n 階段二：加入函式與三人協同開發 \n 協作情境： 三位組員（A、B、C）各自開發一段行走任務，然後將重複動作寫成函式，合併到專案。 \n \n 組員 A:  讓機器人前進 3 格\n for i in range(3):\n    move()\n \n \n 組員 B:  機器人轉 2 次左\n for i in range(2):\n    turn_left()\n \n \n 組員 C:  機器人檢查物件並撿取\n if object_here():\n    take()\n \n \n \n 協作流程： 三人各自建立分支（feature/A, feature/B, feature/C），在 GitHub 上合併 Pull Request，最後由主分支整合。 \n Git 基本指令與說明 \n \n Step 1：初始化本地倉庫 \n git init\n     \n 在專案資料夾裡執行，建立 Git 管理的本地倉庫。 \n Step 2：加入遠端 GitHub 倉庫 \n git remote add origin https://github.com/你的帳號或組織/專案名稱.git\n     \n 將本地倉庫連結到 GitHub 上的遠端 repository。 \n Step 3：建立並切換到功能分支 \n git checkout -b feature/A        # 組員A\ngit checkout -b feature/B        # 組員B\ngit checkout -b feature/C        # 組員C\n     \n 每位組員建立自己的功能分支，分工開發。 \n Step 4：修改程式並加入暫存區 \n git add reeborg.py\n     \n 將變更過的檔案加入暫存區，準備提交。 \n Step 5：提交更動 \n git commit -m "描述這次開發的內容"\n     \n 將暫存區的變更提交到本地倉庫。 \n Step 6：推送分支到 GitHub \n git push -u origin feature/A        # 組員A\ngit push -u origin feature/B        # 組員B\ngit push -u origin feature/C        # 組員C\n     \n 把每個人的分支推到遠端 GitHub。 \n Step 7：建立 Pull Request 並審查合併     到 GitHub 網站上建立 Pull Request（PR），請其他組員 code review，審查無誤後合併到主分支（main）。 \n Step 8：將最新主分支同步回本地 \n git checkout main\ngit pull\n     \n 確保本地 main 跟遠端同步。 \n \n 加入共用函式 \n def turn(times):\n    for i in range(times):\n        turn_left()\n\ndef new_move(steps):\n    for i in range(steps):\n        move()\n \n 階段三：重構與加入迴圈、條件與函式應用 \n 將重複採收動作寫成  harvest_one_row()  函式，結合前進與轉彎，流程更清晰。 \n def harvest_one_row():\n    while object_here():\n        take()\n    else:\n        move()\n \n 階段四：導入 class，建立泛用 Reeborg 機器人控制架構 \n class ReeborgBot:\n    def turn(self, times):\n        for i in range(times):\n            turn_left()\n    def move_steps(self, steps):\n        for i in range(steps):\n            move()\n    def harvest_one_row(self):\n        while object_here():\n            take()\n        else:\n            move()\n    def harvest_field(self, rows, row_length):\n        for i in range(rows):\n            for j in range(row_length):\n                self.harvest_one_row()\n            if i != rows - 1:\n                self.turn(3)\n                self.move_steps(1)\n                self.turn(3)\n                self.move_steps(1)\n\n# 使用範例\nbot = ReeborgBot()\nbot.move_steps(2)\nturn_left()\nbot.move_steps(2)\nbot.harvest_field(3, 6)\n \n 協作開發流程與 Git/GitHub 應用摘要 \n \n git init ：建立本地專案。 \n git branch feature/A 、 git branch feature/B 、 git branch feature/C ：三位組員各自建立分支（或用  git checkout -b  一次完成）。 \n git add 、 git commit 、 git push ：將各自更動上傳到 GitHub。 \n Pull Request ：在 GitHub 建立 PR，進行 code review 與合併。 \n 遇重複邏輯，抽象為函式，用新分支推送與合併。 \n 最後導入 class，建立泛用控制架構，提升可維護性與擴充性。 \n \n 結語 \n 本例展示 Python 基礎語法、函式、類別應用，以及如何善用 Git/GitHub 進行協同開發，讓團隊程式碼更有架構、易於管理與擴展。 \n', 'tags': '', 'url': 'Git_ex1.html'}, {'title': 'Git_ex2', 'text': '三人協同開發 Reeborg 程式：Git/GitHub 詳細流程與指令 \n 專案設計演進與協作分工 \n \n 階段一：初始設計（三人各自撰寫基本功能） \n \n Alice：負責機器人移動與左轉基本動作 \n Bob：設計撿取物件的邏輯 \n Carol：設計主程式流程與方向判斷 \n \n # Alice\nmove()\nmove()\nturn_left()\nmove()\n\n# Bob\nif object_here():\n    take()\n\n# Carol\nwhile not is_facing_north():\n    turn_left()\n     \n git 指令： \n \n \n 三人各自建立分支並上傳初步程式片段 \n \n \n git checkout -b feature/move  # Alice\ngit checkout -b feature/take  # Bob\ngit checkout -b feature/dir   # Carol\n\ngit add reeborg.py\ngit commit -m "初步功能"\ngit push -u origin feature/move  # Alice\ngit push -u origin feature/take  # Bob\ngit push -u origin feature/dir   # Carol \n \n 階段二：重複迴圈設計（逐步將動作包裝為迴圈） \n \n Alice：將移動與轉向包裝進 for 迴圈 \n Bob：將撿取物件行為放入 while 迴圈 \n \n # Alice\nfor i in range(3):\n    move()\n\nfor i in range(2):\n    turn_left()\n\n# Bob\nwhile object_here():\n    take()\n     \n git 指令： \n \n \n 各自於分支更新程式並提交 \n \n \n git add reeborg.py\ngit commit -m "加入重複迴圈"\ngit push\n       \n \n 階段三：Function 封裝設計（將重複邏輯抽象為函式） \n \n Alice：設計  new_move 、 turn 、 turn_right \n Bob：設計  harvest_one_row ，用 global 記錄物件數 \n Carol：設計  is_facing_east  與主流程 \n \n def turn(n):\n    for i in range(n):\n        turn_left()\n\ndef turn_right():\n    for i in range(3):\n        turn_left()\n\ndef new_move(n):\n    for i in range(n):\n        move()\n\ndef harvest_one_row():\n    global object_taken\n    while object_here() and object_taken < 36:\n        take()\n        object_taken += 1\n    if object_taken < 36:\n        move()\n\ndef is_facing_east():\n    count = 0\n    while not is_facing_north():\n        turn_left()\n        count += 1\n        if count == 4:\n            break\n    turn(3)\n    return True\n     \n git 指令： \n \n \n 各自於分支完成函式開發 \n \n \n git add reeborg.py\ngit commit -m "完成 function 封裝"\ngit push \n \n 階段四：導入 class-based 設計（最終彈性架構） \n \n Alice、Bob、Carol 協作將函式整合為 class，提升可維護性 \n \n class ReeborgBot:\n    def __init__(self):\n        self.object_taken = 0\n\n    def turn(self, n):\n        for i in range(n):\n            turn_left()\n    \n    def turn_right(self):\n        for i in range(3):\n            turn_left()\n\n    def new_move(self, n):\n        for i in range(n):\n            move()\n    \n    def harvest_one_row(self):\n        while object_here() and self.object_taken < 36:\n            take()\n            self.object_taken += 1\n        if self.object_taken < 36:\n            move()\n    \n    def is_facing_east(self):\n        count = 0\n        while not is_facing_north():\n            turn_left()\n            count += 1\n            if count == 4:\n                break\n        self.turn(3)\n        return True\n\n    def harvest_field(self):\n        self.new_move(2)\n        self.turn(1)\n        self.new_move(2)\n        done = False\n        while self.is_facing_east() and not done:\n            for _ in range(2):\n                for _ in range(6):\n                    self.harvest_one_row()\n                    if self.object_taken >= 36:\n                        done = True\n                        break\n                if done: break\n                for _ in range(2):\n                    self.turn(1)\n                    move()\n                for _ in range(6):\n                    self.harvest_one_row()\n                    if self.object_taken >= 36:\n                        done = True\n                        break\n                if done: break\n                for _ in range(2):\n                    self.turn_right()\n                    move()\n            if self.object_taken >= 36:\n                print("task completed!")\n                break\n\n# 使用範例\nbot = ReeborgBot()\nbot.harvest_field()\n     \n git 指令： \n \n \n 協作於 feature/class-based 分支整合 class 架構 \n \n \n git checkout -b feature/class-based\n# 合併 Alice/Bob/Carol 分支或直接在此分支重構\ngit add reeborg.py\ngit commit -m "整合 class-based 架構"\ngit push -u origin feature/class-based \n \n \n 專案開發分工摘要表 \n \n \n \n 組員 \n 負責內容 \n Git 分支名稱 \n \n \n Alice \n 基本移動與轉向（ new_move 、 turn 、 turn_right ） \n feature/move-turn \n \n \n Bob \n 收成邏輯（ harvest_one_row 、 object_taken ） \n feature/harvest \n \n \n Carol \n 方向判斷與主流程（ is_facing_east 、主執行流程） \n feature/main-loop \n \n \n \n GitHub 操作 Step by Step \n \n 由一位組員（如 Alice）新建 repo （如  reeborg-harvest ） \n 本地初始化： \n git clone https://github.com/your-org/reeborg-harvest.git\ncd reeborg-harvest \n \n 建立主分支 main： \n git checkout -b main\ngit push -u origin main \n \n 三位組員各自分出功能分支： \n git checkout -b feature/move-turn      # Alice\ngit checkout -b feature/harvest        # Bob\ngit checkout -b feature/main-loop      # Carol \n \n 推送分支到遠端： \n git push -u origin feature/move-turn      # Alice\ngit push -u origin feature/harvest        # Bob\ngit push -u origin feature/main-loop      # Carol \n \n 組員於各自分支開發程式並提交： \n git add reeborg.py\ngit commit -m "功能/重構/修正說明"\ngit push \n \n 建立 Pull Request（PR）並 Code Review： \n \n 於 GitHub 建立 PR，標明合併分支、審查人員、功能說明 \n 進行 code review，提出建議與修正 \n 審查通過後合併 PR（Merge pull request） \n \n \n main 分支同步至本地： \n git checkout main\ngit pull \n \n \n 後續協作建議 \n \n \n 每次新增功能或修正前，請先拉新分支，勿直接在 main 分支作業： \n \n \n git checkout -b feature/新功能 \n \n \n 合併前先同步主分支，解決衝突後再 push： \n \n \n git pull origin main\n# 如有衝突，解決後再\ngit add .\ngit commit -m "解決衝突"\ngit push \n \n 在 Pull Request 詳細描述修改內容與測試方式，方便審查。 \n 善用  git log 、 git status 、 git diff  檢查歷史與變更。 \n \n 常用 Git 指令說明 \n \n git checkout -b 分支名 ：從目前分支新建並切換到分支 \n git add 檔名 ：加入暫存區，準備提交 \n git commit -m "訊息" ：提交更動，寫下本次修改說明 \n git push -u origin 分支名 ：推送分支到遠端 \n git pull ：拉下遠端最新更動並合併 \n git merge 分支名 ：將指定分支合併到目前分支 \n git status ：顯示目前狀態、尚未提交的變更 \n git log ：查詢提交歷史 \n git diff ：顯示檔案內容變更差異 \n \n 結論 \n 本範例展現 Reeborg 機器人從最簡單設計、逐步進化至 class-based 架構的過程，以及三人協同開發的 Git/GitHub 分支工作流。遵循此流程能大幅提升團隊協作、程式碼品質與可維護性。 \n', 'tags': '', 'url': 'Git_ex2.html'}, {'title': 'Python', 'text': 'Learn Python with  Reeborg \n https://reeborg.ca/docs/en/ \n https://aroberge.gitbooks.io/reeborg-s-world-advanced-world-creation/content/ \n https://github.com/loukhin/Reeborg \n https://github.com/aroberge/reeborg-howto \n https://github.com/LeeRenJie/100-days-of-code-in-python \n Self-taught programmer \n Python code for Artificial Intelligence - Foundations of Computational Agents \n https://artint.info/AIPython/aipython.pdf \n Program AI with Python \n AI with Python \n Using Python for Artificial Intelligence \n Machine Learning with Python Tutorial \n Genetic Algorithms: \n ga_1.py  (from  https://www.geeksforgeeks.org/genetic-algorithms/ ) \n https://medium.com/analytics-vidhya/genetic-algorithm-494ac5be18bb \n https://medium.com/@LeonFedden/evolving-solutions-with-genetic-algorithms-e3122473a35f \n Apply GA to  https://github.com/mdecycu/cs101 \n', 'tags': '', 'url': 'Python.html'}, {'title': 'Python_ex1', 'text': 'Python 初學者學習指引 \n 一、學習步驟建議 \n \n 認識 Python 的應用與特色。 \n 選擇合適的學習平台，例如  Reeborg’s World 。 \n 熟悉 Python 的基本語法與執行方式。 \n 從簡單題目逐步挑戰更進階的練習。 \n 多做實作練習，並觀察程式執行結果。 \n \n 二、Python 必學基本語法 \n \n 變數與資料型態： \n x = 10\nname = "Alice"\nis_ok = True \n \n 輸出： \n print("Hello, world!") \n \n 運算子： \n \n 數學運算： + 、 - 、 * 、 / 、 // 、 % \n 比較運算： == 、 != 、 > 、 < \n 邏輯運算： and 、 or 、 not \n \n \n 條件判斷： \n if x > 0:\n    print("正數")\nelse:\n    print("非正數") \n \n 迴圈： \n while 條件:\n    # 重複執行內容\n \n \n 函式： \n def greet():\n    print("Hi!") \n \n 縮排與註解： \n # 這是註解\nif True:\n    print("這行有縮排") \n \n \n 三、Reeborg’s World 學習重點 \n \n 基本指令： \n \n move() ：前進一格 \n turn_left() ：左轉 \n take() ：撿起物品 \n put() ：放下物品 \n \n \n 感測與判斷： \n \n front_is_clear() ：前方有路 \n wall_in_front() ：前方有牆 \n object_here() ：目前格子有物品 \n \n \n 條件與迴圈應用： \n if front_is_clear():\n    move()\nelse:\n    turn_left()\n\nwhile not at_goal():\n    move() \n \n 自訂函式： \n def turn_right():\n    turn_left()\n    turn_left()\n    turn_left() \n \n \n 四、小結 \n \n 先學會基本語法與程式邏輯，再用 Reeborg 練習解題。 \n 多做題目，觀察執行結果與錯誤訊息，提升解決問題能力。 \n 熟悉條件判斷、迴圈、函式，是學好 Python 的基礎。 \n \n \n Python 初學者超詳細學習指引 （以 Reeborg 機器人練習為例） \n 一、Python 學習流程與心法 \n \n 認識 Python \n \n Python 是一種簡潔、易讀、用途廣泛的程式語言。 \n 常用於資料分析、人工智慧、網頁開發、自動化等領域。 \n 學好基礎語法，日後可延伸應用到許多不同領域。 \n \n \n 選擇學習工具 \n \n 初學推薦  Reeborg’s World ，直接練習程式，免安裝。 \n 也可用 Python 官方網站下載安裝，或用線上編輯器（如 repl.it、Google Colab）。 \n \n \n 循序漸進學習 \n \n 先熟悉「變數、運算子、條件、迴圈、函式」等核心語法。 \n 搭配 Reeborg 關卡，練習邏輯與解題。 \n 寫程式要勇於嘗試與修正，錯誤是學習的起點！ \n \n \n 主動多練習、多觀察、多思考 \n \n 練習題目與挑戰，能讓你熟悉語法、訓練邏輯。 \n 觀察程式執行過程與錯誤訊息，學會除錯（debug）。 \n 遇到卡關時，試著將問題拆解成小步驟。 \n \n \n \n 二、Python 基本語法說明與範例 \n \n \n \n 語法主題 \n 說明 \n 範例 \n \n \n 變數 \n 儲存資料（數字、文字、布林值等） \n x = 5 name = "Tom" is_ok = True \n \n \n 資料型態 \n 整數  int 、小數  float 、字串  str 、布林  bool \n a = 7 b = 3.14 c = "Hello" d = False \n \n \n 輸出 \n 用  print()  顯示資訊 \n print("Hello world!") print(x + 2) \n \n \n 運算子 \n 數學、比較、邏輯運算 \n  # 數學  y = x + 1  # 比較  x > 3  # 邏輯  True and False  \n \n \n 條件判斷 \n 根據條件執行不同程式碼 \n  if x > 0:  \xa0\xa0print("正數")  else:  \xa0\xa0print("負數或零")  \n \n \n 迴圈 (while) \n 重複執行，直到條件不成立 \n  count = 0  while count < 3:  \xa0\xa0print(count)  \xa0\xa0count += 1  \n \n \n for 迴圈（了解即可） \n 依序處理序列資料 \n  for i in range(5):  \xa0\xa0print(i)  \n \n \n 函式 \n 將重複動作打包，方便重用 \n  def say_hello():  \xa0\xa0print("Hello!")  say_hello()  \n \n \n 縮排與註解 \n Python 用縮排分區塊，註解用  # \n  # 這是註解  if True:  \xa0\xa0print("有縮排")  \n \n \n \n 小提醒：  Python 不用分號，且縮排必須統一（通常 4 個空格）。 \n 三、Reeborg\'s World 機器人操作重點 \n \n 基本指令 \n \n move() ：前進一格 \n turn_left() ：左轉 90 度 \n take() ：撿起物品 \n put() ：放下物品 \n \n \n 判斷世界狀態的感測器 \n \n front_is_clear() ：前方有路 \n wall_in_front() ：前方有牆 \n right_is_clear() ：右方有路 \n wall_on_right() ：右方有牆 \n object_here() ：目前格子有物品 \n at_goal() ：到達終點 \n \n \n 條件判斷/迴圈應用 \n \nif front_is_clear():\n    move()\nelse:\n    turn_left()\n\nwhile not at_goal():\n    move()\n                 \n \n 自訂函式（提升可讀性與重用） \n \ndef turn_right():\n    for i in range(3):\n        turn_left()\n\ndef pick_and_move():\n    take()\n    move()\n\n# 呼叫自訂函式\nturn_right()\n                 \n \n 解題流程建議 \n \n 仔細閱讀題目與世界設定。 \n 思考機器人要完成哪些步驟（可先畫流程圖）。 \n 將步驟拆解成小動作，分別寫成程式。 \n 適時用  if  或  while  控制流程。 \n 多嘗試、多觀察，多用 print 或步步執行除錯。 \n \n \n \n 常見錯誤： \n \n 少寫小括號（如  move  寫成  move() ）。 \n 縮排錯誤導致語法錯。 \n 無窮迴圈（如 while 條件永遠為真）。 \n \n \n 四、進階建議與常見問題 \n \n 多加練習 \n \n 完成 Reeborg 的所有世界（關卡）。 \n 嘗試設計自己的世界與題目。 \n \n \n 閱讀程式碼，互相學習 \n \n 觀摩別人解法，了解不同邏輯。 \n 勇於提問與討論（如參加線上社群）。 \n \n \n 養成良好習慣 \n \n 適當註解，提高可讀性。 \n 命名有意義的變數與函式。 \n \n \n \n 五、完整學習流程小結 \n \n 學會 Python 基本文法、邏輯思考。 \n 熟練 Reeborg 指令、感測器、流程控制。 \n 多練習、多觀察、多修正。 \n 培養拆解問題、設計函式的能力。 \n 主動探索更多應用與進階技巧。 \n \n', 'tags': '', 'url': 'Python_ex1.html'}, {'title': 'Javascript', 'text': 'JavaScript 初學者完整學習指引 \n 一、為什麼學 JavaScript？ \n \n JavaScript 是網頁開發必學語言，執行於所有主流瀏覽器。 \n 可用於前端（瀏覽器）、後端（Node.js）、行動應用、桌面應用等。 \n 社群大、資源多，學會 JS 等於打開 Web 世界大門。 \n \n 二、學習流程建議 \n \n 認識 JavaScript 應用場景及基礎語法。 \n 熟悉開發與測試環境： 推薦直接在 Chrome、Edge、Firefox 等瀏覽器按 F12 開啟「開發人員工具」→「主控台(Console)」練習。 \n 循序漸進學習語法與邏輯：從變數、流程控制、函式、物件等開始。 \n 多做練習題與小專案。 \n 了解 DOM 操作、事件處理與基礎網頁互動。 \n 進階可學習 ES6+ 新語法與框架（如 React、Vue）。 \n \n 三、JavaScript 必學基礎語法與範例 \n \n \n \n 語法主題 \n 說明 \n 範例 \n \n \n 變數宣告 \n 用  let 、 const （現代 JS）， 不要再用  var 。 \n let x = 10; const pi = 3.14; \n \n \n 資料型態 \n 數字（Number）、字串（String）、布林（Boolean）、陣列（Array）、物件（Object）、null、undefined \n  let s = "hi";  let arr = [1,2,3];  let person = { name: "Tom", age: 20 };  \n \n \n 輸出 \n 用  console.log()  輸出到主控台 \n console.log("Hello!"); console.log(x + 2); \n \n \n 運算子 \n 數學（+、-、*、/、%）、比較（==、===、!=、!==、>、<）、邏輯（&&、||、!） \n  let z = x + 5;  x === 10  (a > 0) && (b < 5)  \n \n \n 條件判斷 \n if、else if、else \n  if (x > 0) {  \xa0\xa0console.log("正數");  } else {  \xa0\xa0console.log("非正數");  }  \n \n \n 迴圈 \n for、while、do...while \n  for (let i = 0; i < 3; i++) {  \xa0\xa0console.log(i);  }    let count = 0;  while (count < 3) {  \xa0\xa0console.log(count);  \xa0\xa0count++;  }  \n \n \n 函式 \n 定義與呼叫，  ES6 支援箭頭函式 \n  function greet(name) {  \xa0\xa0console.log("Hi, " + name);  }  greet("Amy");    // 箭頭函式  const add = (a, b) => a + b;  console.log(add(2,3));  \n \n \n 陣列與物件 \n 基本操作：存取元素、方法如  push 、 forEach  等 \n  let nums = [1,2,3];  nums.push(4);  nums.forEach(item => console.log(item));    let person = { name: "Tom", age: 20 };  console.log(person.name);  \n \n \n 註解 \n 單行  // ，多行  /* */ \n  // 這是單行註解  /*  這是多行註解  */  \n \n \n \n 小提醒：  JavaScript 語法彈性大，但容易出現隱含錯誤，建議使用嚴格模式  \'use strict\'; ，養成良好命名與註解習慣。 \n 四、在網頁上的應用簡介 \n \n JavaScript 主要用於網頁互動、動態內容與事件處理。 \n 可透過  <script>  標籤直接在 HTML 內嵌或引用外部 JS 檔案： \n \n <!DOCTYPE html>\n<html>\n<head><title>JS 範例</title></head>\n<body>\n  <button onclick="sayHello()">點我</button>\n  <script>\n    function sayHello() {\n      alert("你好！");\n    }\n  </script>\n</body>\n</html> \n 五、常見錯誤與學習建議 \n \n 常見錯誤： \n \n 少分號或括號（雖然 JS 支援自動補全，但還是建議加上）。 \n 變數未宣告直接使用。 \n 區分  == （寬鬆相等）與  === （嚴格相等）。 \n 陣列與物件存取語法錯誤。 \n \n \n 學習建議： \n \n 多練習：在主控台嘗試各種語法。 \n 閱讀 MDN（Mozilla Developer Network）文件，查詢 JS 語法與用法。 \n 完成小專案，如計算機、Todo List、網頁互動等。 \n 多與他人討論，參加線上社群。 \n \n \n \n 六、進階主題（可視情況逐步學習） \n \n ES6+ 新語法（let、const、箭頭函式、解構賦值、展開運算子、模組化等） \n 事件處理、DOM 操作與網頁互動 \n 非同步程式（callback、Promise、async/await） \n 物件導向程式設計、類別（class） \n 前端框架（如 React、Vue、Angular） \n Node.js 伺服器端開發 \n \n', 'tags': '', 'url': 'Javascript.html'}, {'title': 'HTML and CSS', 'text': 'HTML & CSS 初學者學習指南 \n 一、HTML 與 CSS 是什麼？ \n \n HTML（超文件標記語言） ：負責「網頁內容」與「結構」的描述，是網頁的骨架。 \n CSS（層疊樣式表） ：負責「網頁外觀、樣式、版面」的設計，是網頁的皮膚與裝飾。 \n 兩者配合，讓你能打造美觀、結構良好的網站。 \n \n 二、學習步驟建議 \n \n 了解 HTML 與 CSS 各自用途與基本概念。 \n 從基礎標籤（如  <h1> 、 <p> 、 <img> ）與基本樣式（如顏色、字體、邊距）學起。 \n 邊學邊練習：可用  CodePen 、 JSFiddle 、本地文字編輯器練習。 \n 模仿簡單網頁，了解版型與排版原理。 \n 逐步學習表格、表單、版面配置（如 Flexbox、Grid）。 \n 挑戰自製個人履歷網頁、作品集、Landing Page 等小專案。 \n \n 三、HTML 必學標籤與語法 \n \n \n \n 標籤 \n 用途 \n 範例 \n \n \n <h1>  ~  <h6> \n 標題（h1 最大） \n <h1>主標題</h1> \n \n \n <p> \n 段落文字 \n <p>這是一段文字。</p> \n \n \n <a> \n 超連結 \n <a href="https://google.com">Google</a> \n \n \n <img> \n 插入圖片 \n <img src="cat.jpg" alt="貓咪"> \n \n \n <ul> 、 <ol> 、 <li> \n 無序/有序清單 \n  <ul>  \xa0\xa0<li>項目1</li>  \xa0\xa0<li>項目2</li>  </ul>  \n \n \n <div>  /  <span> \n 區塊/行內分組、CSS 樣式輔助 \n <div class="box">內容</div> \n \n \n <table> 、 <tr> 、 <td> \n 表格 \n  <table>  \xa0\xa0<tr><td>A</td><td>B</td></tr>  </table>  \n \n \n <form> 、 <input> \n 表單與輸入欄位 \n  <form>  \xa0\xa0<input type="text" placeholder="姓名">  </form>  \n \n \n \n 四、CSS 必學語法與範例 \n \n 基本選擇器： 元素 、 .類別 、 #ID \n 常用屬性： color （文字顏色）、 background （背景）、 font-size 、 width 、 height 、 margin 、 padding 、 border \n 文字對齊（ text-align ）、區塊對齊（ display 、 flex 、 grid ） \n CSS 寫法可在  <style>  標籤、 style  屬性或獨立 .css 檔案 \n \n \n/* 樣式檔範例 */\nh1 {\n    color: #2d7f5e;\n    font-size: 2em;\n    text-align: center;\n}\n.box {\n    background: #eaffea;\n    padding: 1em;\n    border-radius: 8px;\n    margin-bottom: 1em;\n}\n#main {\n    width: 80%;\n    margin: auto;\n}\n         \n 小技巧： \n \n 多善用瀏覽器「檢查元素」功能，調整 CSS 效果。 \n CSS 有「繼承」與「選擇器優先權」概念，遇到樣式衝突時要注意。 \n \n \n 五、常見練習與專案 \n \n 練習製作個人履歷網頁、名片網站、簡單 Landing Page。 \n 模仿喜歡的網站版型，重新切版練習。 \n 挑戰 CSS Flexbox、Grid 排版。 \n 試著設計表單、導航列、圖文混排區塊。 \n \n 六、常見錯誤與學習建議 \n 常見錯誤： \n \n HTML 標籤忘記閉合、層級錯誤。 \n CSS 拼字錯誤、屬性寫錯或分號遺漏。 \n 選擇器優先權搞混，導致樣式沒套用。 \n class 與 id 用法混淆。 \n \n \n \n 多手寫、多練習，熟悉標籤與屬性。 \n 常用  MDN Web Docs  查詢 HTML/CSS 語法。 \n 參加線上挑戰如  Frontend Mentor 、 CSS Battle 。 \n \n 七、進階主題推薦 \n \n RWD 響應式網頁設計（media query） \n CSS 動畫與過渡（animation, transition） \n SCSS/SASS 等 CSS 預處理器 \n Bootstrap、Tailwind CSS 等框架 \n 網頁無障礙（a11y）設計 \n \n', 'tags': '', 'url': 'HTML and CSS.html'}, {'title': 'Project', 'text': '請協助撰寫一個 Python Flask 網頁應用程式，前端表單需包含： 1. 一個「通關密碼」輸入欄位（用於驗證操作權限） 2. 一個可填入使用者學號的欄位 3. 一個用於設定新電子郵箱密碼的欄位 4. 一個用於確認新電子郵箱密碼的欄位 使用者填寫上述欄位並提交表單後，系統應自動於 Google Workspace 平台建立對應的 email 帳號。 \n \n \n 專案提案書：自動化 Google Workspace 帳號建立 Flask 應用程式 一、專案背景與目標 隨著組織規模成長，IT 部門需經常協助新員工建立 Google Workspace（G Suite）電子郵箱帳號。為提升效率、降低人為疏失及強化資安控管，本專案擬開發一個簡易 Web 應用程式，允許經授權者透過表單操作，自動於 Google Workspace 建立新 email 帳號。 二、需求說明 \n 1. 前端表單功能： \xa0 \xa0- 通關密碼欄位（授權驗證） \xa0 \xa0- 可填入學號數字的欄位 \xa0 \xa0- 電子郵箱密碼欄位 \xa0 \xa0- 確認電子郵箱密碼欄位 \xa0 \xa0- 按下送出後，系統自動於 Google Workspace 建立對應帳號 2. 安全性設計：\xa0 \xa0 \xa0- 必須驗證通關密碼 \xa0 \xa0- 僅允許授權人員操作 (例如: 只允許在特定網段進行操作) \xa0 \xa0- 檢查 email 格式與密碼強度 \xa0 \xa0- 禁止重複帳號建立 \xa0 \xa0- 僅允許數字做為帳號前綴 三、技術規劃 1. 技術需求 - Python 3.x - Flask — 前後端 Web 框架 - google-api-python-client — Google Workspace API 操作 - google-auth — 驗證與授權 - Jinja2 — 表單模板（隨 Flask 內建） - pip — Python 套件管理 2. 開發與部署環境 - 建議部署於安全的內部伺服器或 Docker 容器 - 僅開放組織內部網路存取 四、安裝說明 1. Python 套件安裝 請於專案目錄下執行： \n pip install Flask google-api-python-client google-auth \n 如需管理虛擬環境，建議搭配 venv 或 conda 使用。 2. Google Workspace API 準備 1. 建立 Google Cloud Platform 專案並啟用 Admin SDK API 2. 建立 Service Account，下載憑證檔（JSON） 3. 設定 Domain-wide Delegation（網域代理授權） 4. 於 Google Workspace 管理控制台授權 API 的 OAuth2 Scope： \xa0 \xa0- https://www.googleapis.com/auth/admin.directory.user 五、各階段程式碼設計 1. 表單頁面（Flask/Jinja2） python name=templates/form.html \n <!doctype html>\n<title>建立 Google Workspace 帳號</title>\n<h2>建立 Google Workspace 帳號</h2>\n<form method="POST">\n  <label>通關密碼：<input type="password" name="secret" required></label><br>\n  <label>學號：<input type="text" name="prefix" required></label><br>\n<hr>\n以下密碼必須符合：<br>\n至少 8 個字元<br>\n建議包含：<br>\n大寫 + 小寫字母<br>\n數字<br>\n特殊字元（如 !@#$)<br>\n<hr>\n  <label>新帳號密碼：<input type="password" name="account_password" required></label><br>\n  <label>確認密碼：<input type="password" name="confirm_password" required></label><br>\n  <input type="submit" value="送出">\n</form>\n{% with messages = get_flashed_messages() %}\n  {% if messages %}\n    <ul>\n    {% for message in messages %}\n      <li>{{ message }}</li>\n    {% endfor %}\n    </ul>\n  {% endif %}\n{% endwith %}\n \n 2. Flask 應用程式主體 python name=app.py \n from flask import Flask, render_template, request, redirect, url_for, flash\nfrom google.oauth2 import service_account\nfrom googleapiclient.discovery import build\nimport os\n \napp = Flask(__name__)\napp.secret_key = os.urandom(24)\n \n# 組態設定\nDOMAIN = "your_domain_name"\nADMIN_EMAIL = "your_admin_email"\nSERVICE_ACCOUNT_FILE = "C:/your_account_file_directory/service.json"\nPASSWORD_SECRET = "your_password_secret"\nSCOPES = [\'https://www.googleapis.com/auth/admin.directory.user\']\n \ndef create_user(email_prefix, password):\n    credentials = service_account.Credentials.from_service_account_file(\n        SERVICE_ACCOUNT_FILE, scopes=SCOPES)\n    delegated_credentials = credentials.with_subject(ADMIN_EMAIL)\n    service = build(\'admin\', \'directory_v1\', credentials=delegated_credentials)\n    user_body = {\n        "primaryEmail": f"{email_prefix}@{DOMAIN}",\n        "name": {\n            "givenName": email_prefix,\n            "familyName": "User"\n        },\n        "password": password\n    }\n    user = service.users().insert(body=user_body).execute()\n    return user\n \n@app.route(\'/\', methods=[\'GET\', \'POST\'])\ndef index():\n    if request.method == \'POST\':\n        secret = request.form[\'secret\']\n        prefix = request.form[\'prefix\']\n        account_password = request.form[\'account_password\']\n        confirm_password = request.form[\'confirm_password\']\n\n        # 權限驗證\n        if secret != PASSWORD_SECRET:\n            flash("通關密碼錯誤！")\n            return redirect(url_for(\'index\'))\n        \n        if not prefix.isdigit():\n            flash("請輸入您的學號")\n            return redirect(url_for(\'index\'))\n        \n        # 密碼確認\n        if account_password != confirm_password:\n            flash("兩次密碼不一致，請重新確認！")\n            return redirect(url_for(\'index\'))\n        \n        # 密碼驗證（可加入更多規則）\n        if len(account_password) < 8:\n            flash("密碼長度必須至少 8 個字元！")\n            return redirect(url_for(\'index\'))\n        \n        try:\n            result = create_user(prefix, account_password)\n            flash(f"帳號建立成功: {result[\'primaryEmail\']}")\n        except Exception as e:\n            flash(f"建立帳號失敗: {str(e)}")\n        return redirect(url_for(\'index\'))\n    return render_template(\'form.html\')\n \nif __name__ == \'__main__\':\n    app.run(debug=True)\n \n 3. 進階安全考量建議 - 密碼建議採用強度檢查（可用 Python 密碼強度套件輔助） - 增加帳號是否已存在的查核（可用 Google Workspace API 查詢帳號） - 日誌記錄所有操作，便於稽核 - 部署於 HTTPS 環境 - 建議將通關密碼與 API 金鑰資訊寫於環境變數或安全檔案，避免硬編碼 六、操作說明 1. 啟動服務 python app.py 預設於 http://localhost:5000 提供服務。 2. 使用流程 1. 開啟瀏覽器進入應用頁面 2. 輸入通關密碼 3. 輸入欲建立 email 的數字帳號前綴（如 123） 4. 設定對應帳號密碼 5. 按下送出，成功後將顯示建立結果 七、時程規劃（建議） \n \n \n \n 階段 \n 工作項目 \n 預計工期 \n \n \n \n \n 需求確認 \n 討論細節與權限 \n 1 天 \n \n \n 環境建置 \n API/Flask/金鑰設定 \n 1 天 \n \n \n 程式開發 \n 表單與自動化功能撰寫 \n 2 天 \n \n \n 測試驗證 \n 各種狀況測試與修正 \n 1 天 \n \n \n 上線部署 \n 內部伺服器或容器部署 \n 1 天 \n \n \n 文件彙整 \n 操作手冊與維運說明 \n 1 天 \n \n \n \n 八、結論 本專案將顯著提升 IT 人員建立 Google Workspace 帳號的效率與一致性，同時兼顧資訊安全。未來可依需求擴充驗證機制或加入更多自動化管理功能，如帳號停用、密碼重設等。 \n', 'tags': '', 'url': 'Project.html'}, {'title': 'Waitress', 'text': '採  waitress  執行 app.py \n start_app.py 程式碼: \n from waitress import serve\nfrom app import app  # 這裡導入 app.py 中的 Flask 應用\n\n# 這裡的 127.0.0.1:5000 是服務監聽的地址與端口\nserve(app, listen=\'127.0.0.1:5000\', threads=8)\n \n 利用  waitress  執行的 app.py 程式碼: \n # pip install Flask google-api-python-client google-auth\nfrom flask import Flask, render_template, request, redirect, url_for, flash\nfrom google.oauth2 import service_account\nfrom googleapiclient.discovery import build\nimport os\n\napp = Flask(__name__)\napp.secret_key = os.urandom(24)\n\n# 組態設定\nDOMAIN = "your_google_workspace_domain"\nADMIN_EMAIL = "yout_admin_email"\nSERVICE_ACCOUNT_FILE = "C:/your_service_account_file_directory/service.json"\nPASSWORD_SECRET = "your_passwod_secret"\nSCOPES = [\'https://www.googleapis.com/auth/admin.directory.user\']\n\ndef create_user(email_prefix, password):\n    credentials = service_account.Credentials.from_service_account_file(\n        SERVICE_ACCOUNT_FILE, scopes=SCOPES)\n    delegated_credentials = credentials.with_subject(ADMIN_EMAIL)\n    service = build(\'admin\', \'directory_v1\', credentials=delegated_credentials)\n    user_body = {\n        "primaryEmail": f"{email_prefix}@{DOMAIN}",\n        "name": {\n            "givenName": email_prefix,\n            "familyName": "User"\n        },\n        "password": password\n    }\n    user = service.users().insert(body=user_body).execute()\n    return user\n\n@app.route(\'/\', methods=[\'GET\', \'POST\'])\ndef index():\n    if request.method == \'POST\':\n        secret = request.form[\'secret\']\n        prefix = request.form[\'prefix\']\n        account_password = request.form[\'account_password\']\n        confirm_password = request.form[\'confirm_password\']\n\n        # 權限驗證\n        if secret != PASSWORD_SECRET:\n            flash("通關密碼錯誤！")\n            return redirect(url_for(\'index\'))\n        \n        if not prefix.isdigit():\n            flash("請輸入您的學號")\n            return redirect(url_for(\'index\'))\n        \n        # 密碼確認\n        if account_password != confirm_password:\n            flash("兩次密碼不一致，請重新確認！")\n            return redirect(url_for(\'index\'))\n        \n        # 密碼驗證（可加入更多規則）\n        if len(account_password) < 8:\n            flash("密碼長度必須至少 8 個字元！")\n            return redirect(url_for(\'index\'))\n        \n        try:\n            result = create_user(prefix, account_password)\n            flash(f"帳號建立成功: {result[\'primaryEmail\']}")\n        except Exception as e:\n            flash(f"建立帳號失敗: {str(e)}")\n        return redirect(url_for(\'index\'))\n    return render_template(\'form.html\')\n\n# 不使用 app.run()，讓 waitress 來處理\n \n 配合使用的 nginx.conf \n worker_processes  1;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n\n    server {\n        listen       [::]:80 ipv6only=on;\n        server_name  your_first_server_domain your_server_cname_domain;\n\n        #root   html;\n        # 將 port 80 http 連結到倉儲的靜態網站\n        root C:/your_static_site_directory/wcm2025_hw;\n        index  index.html;\n\n        location / {\n            try_files $uri $uri/ =404;\n        }\n    }\n\n    server {\n        listen       [::]:443 ssl ipv6only=on;\n        http2        on;\n        server_name  your_first_server_domain your_server_cname_domain;\n\n        ssl_certificate      fullchain.pem;\n        ssl_certificate_key  privkey.pem;\n        ssl_protocols        TLSv1.2 TLSv1.3;\n        ssl_ciphers          HIGH:!aNULL:!MD5;\n\n        location / {\n            # https port 443 的連結資料是由近端 IPv6 or IPv4 port 8080 所提供\n            #proxy_pass         http://[::1]:5000;\n            proxy_pass         http://127.0.0.1:5000;\n            proxy_set_header   Host $host;\n            proxy_set_header   X-Real-IP $remote_addr;\n            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header   X-Forwarded-Proto $scheme;\n        }\n    }\n} \n 初步測試所使用的單一通關密碼進行驗證，可以再透過\xa0flask-pyoidc 改為  OIDC  認證通關: \n 先安裝必要模組: \n pip install Flask flask-pyoidc google-api-python-client google-auth \n 接著登入 Google Cloud Console 建立 OAuth 2.0 憑證: \n \n 登入 Google Cloud Console \n 選擇你的專案，點選「建立憑證」>「OAuth 用戶端 ID」 \n 選擇「Web 應用程式」 \n 設定授權的重新導向 URI（Redirect URI） \n 例如：http://localhost:5000/oidc/callback \n 取得「用戶端 ID」與「用戶端密鑰」 \n \n 接著建立 OIDC 設定檔: 將下列內容儲存為 oidc_secrets.json（請填入你自己的 client_id/client_secret）： \n {\n  "web": {\n    "client_id": "YOUR_CLIENT_ID",\n    "client_secret": "YOUR_CLIENT_SECRET",\n    "auth_uri": "https://accounts.google.com/o/oauth2/auth",\n    "token_uri": "https://oauth2.googleapis.com/token",\n    "issuer": "https://accounts.google.com",\n    "redirect_uris": ["http://localhost:5000/oidc/callback"]\n  }\n} \n 利用 OIDC 認證通關的 app.py: \n # pip install Flask flask-pyoidc google-api-python-client google-auth\nfrom flask import Flask, render_template, request, redirect, url_for, flash, session\nfrom flask_pyoidc import OIDCAuthentication\nfrom flask_pyoidc.provider_configuration import ProviderConfiguration, ClientMetadata\nfrom google.oauth2 import service_account\nfrom googleapiclient.discovery import build\nimport os\nimport json\n\napp = Flask(__name__)\napp.secret_key = os.urandom(24)\n\n# === OIDC 設定 ===\nwith open(\'oidc_secrets.json\') as f:\n    oidc_conf = json.load(f)[\'web\']\n\nissuer = oidc_conf[\'issuer\']\nclient_metadata = ClientMetadata(\n    client_id=oidc_conf[\'client_id\'],\n    client_secret=oidc_conf[\'client_secret\'],\n    post_logout_redirect_uris=[oidc_conf[\'redirect_uris\'][0]]\n)\nprovider_config = ProviderConfiguration(\n    issuer=issuer,\n    client_metadata=client_metadata\n)\nauth = OIDCAuthentication({\'default\': provider_config}, app)\n\n# === Google Workspace 設定 ===\nDOMAIN = "your_google_workspace_domain"\nADMIN_EMAIL = "your_admin_email"\nSERVICE_ACCOUNT_FILE = "C:/your_service_account_file_directory/service.json"\nSCOPES = [\'https://www.googleapis.com/auth/admin.directory.user\']\n\ndef create_user(email_prefix, password):\n    credentials = service_account.Credentials.from_service_account_file(\n        SERVICE_ACCOUNT_FILE, scopes=SCOPES)\n    delegated_credentials = credentials.with_subject(ADMIN_EMAIL)\n    service = build(\'admin\', \'directory_v1\', credentials=delegated_credentials)\n    user_body = {\n        "primaryEmail": f"{email_prefix}@{DOMAIN}",\n        "name": {\n            "givenName": email_prefix,\n            "familyName": "User"\n        },\n        "password": password\n    }\n    user = service.users().insert(body=user_body).execute()\n    return user\n\n@app.route(\'/logout\')\ndef logout():\n    # 清除 session 並 redirect 回首頁\n    session.clear()\n    return redirect(auth.client_end_session_uri(\'default\', url_for(\'index\', _external=True)))\n\n@app.route(\'/\', methods=[\'GET\', \'POST\'])\n@auth.oidc_auth(\'default\')\ndef index():\n    # 取得登入者資訊\n    user_session = auth.user_session\n    user_email = user_session.userinfo[\'email\']\n\n    # 只允許特定網域\n    if not user_email.endswith(\'@your_google_workspace_domain\'):\n        return "無權限，請使用組織帳號登入", 403\n\n    if request.method == \'POST\':\n        prefix = request.form[\'prefix\']\n        account_password = request.form[\'account_password\']\n        confirm_password = request.form[\'confirm_password\']\n\n        if not prefix.isdigit():\n            flash("請輸入您的學號")\n            return redirect(url_for(\'index\'))\n\n        if account_password != confirm_password:\n            flash("兩次密碼不一致，請重新確認！")\n            return redirect(url_for(\'index\'))\n\n        if len(account_password) < 8:\n            flash("密碼長度必須至少 8 個字元！")\n            return redirect(url_for(\'index\'))\n\n        try:\n            result = create_user(prefix, account_password)\n            flash(f"帳號建立成功: {result[\'primaryEmail\']}")\n        except Exception as e:\n            flash(f"建立帳號失敗: {str(e)}")\n        return redirect(url_for(\'index\'))\n    return render_template(\'form.html\', user_email=user_email) \n 配合 OIDC 認證的 form.html: \n <!doctype html>\n<title>建立 Google Workspace 帳號</title>\n<h2>建立 Google Workspace 帳號</h2>\n<p>目前登入：{{ user_email }}</p>\n<form method="POST">\n  <label>學號（Email @ 前）：<input type="text" name="prefix" required pattern="\\d+"></label><br>\n  <label>新帳號密碼：<input type="password" name="account_password" required></label><br>\n  <label>再次輸入密碼：<input type="password" name="confirm_password" required></label><br>\n  <input type="submit" value="送出">\n</form>\n{% with messages = get_flashed_messages() %}\n  {% if messages %}\n    <ul>\n    {% for message in messages %}\n      <li>{{ message }}</li>\n    {% endfor %}\n    </ul>\n  {% endif %}\n{% endwith %}\n<a href="{{ url_for(\'logout\') }}">登出</a> \n 之後假設透過收集用戶的 email address 存為 allowed_email.txt， 採 OIDC 認證流程時，只允許電子郵箱在此檔案中的用戶有權限利用 app.py 建立 Google Workspace 帳號, 則 app.py 配合修改如下: \n from flask import Flask, render_template, request, redirect, url_for, flash, session\nfrom flask_pyoidc import OIDCAuthentication\nfrom flask_pyoidc.provider_configuration import ProviderConfiguration, ClientMetadata\nfrom google.oauth2 import service_account\nfrom googleapiclient.discovery import build\nimport os\nimport json\n\napp = Flask(__name__)\napp.secret_key = os.urandom(24)\n\n# 讀取 allowed_email.txt，存成 set\ndef load_allowed_emails(filepath="allowed_email.txt"):\n    with open(filepath, encoding="utf-8") as f:\n        return set(line.strip().lower() for line in f if line.strip())\n\nALLOWED_EMAILS = load_allowed_emails()\n\n# === OIDC 設定 ===\nwith open(\'oidc_secrets.json\') as f:\n    oidc_conf = json.load(f)[\'web\']\n\nissuer = oidc_conf[\'issuer\']\nclient_metadata = ClientMetadata(\n    client_id=oidc_conf[\'client_id\'],\n    client_secret=oidc_conf[\'client_secret\'],\n    post_logout_redirect_uris=[oidc_conf[\'redirect_uris\'][0]]\n)\nprovider_config = ProviderConfiguration(\n    issuer=issuer,\n    client_metadata=client_metadata\n)\nauth = OIDCAuthentication({\'default\': provider_config}, app)\n\n# === Google Workspace 設定 ===\nDOMAIN = "your_google_workspace_domain"\nADMIN_EMAIL = "your_admin_email"\nSERVICE_ACCOUNT_FILE = "C:/your_service_account_file_directory/service.json"\nSCOPES = [\'https://www.googleapis.com/auth/admin.directory.user\']\n\ndef create_user(email_prefix, password):\n    credentials = service_account.Credentials.from_service_account_file(\n        SERVICE_ACCOUNT_FILE, scopes=SCOPES)\n    delegated_credentials = credentials.with_subject(ADMIN_EMAIL)\n    service = build(\'admin\', \'directory_v1\', credentials=delegated_credentials)\n    user_body = {\n        "primaryEmail": f"{email_prefix}@{DOMAIN}",\n        "name": {\n            "givenName": email_prefix,\n            "familyName": "User"\n        },\n        "password": password\n    }\n    user = service.users().insert(body=user_body).execute()\n    return user\n\n@app.route(\'/logout\')\ndef logout():\n    session.clear()\n    return redirect(auth.client_end_session_uri(\'default\', url_for(\'index\', _external=True)))\n\n@app.route(\'/\', methods=[\'GET\', \'POST\'])\n@auth.oidc_auth(\'default\')\ndef index():\n    user_session = auth.user_session\n    user_email = user_session.userinfo[\'email\'].lower()\n\n    # 只允許在 allowed_email.txt 的 email\n    if user_email not in ALLOWED_EMAILS:\n        return render_template(\'not_allowed.html\', user_email=user_email), 403\n\n    if request.method == \'POST\':\n        prefix = request.form[\'prefix\']\n        account_password = request.form[\'account_password\']\n        confirm_password = request.form[\'confirm_password\']\n\n        if not prefix.isdigit():\n            flash("請輸入您的學號")\n            return redirect(url_for(\'index\'))\n\n        if account_password != confirm_password:\n            flash("兩次密碼不一致，請重新確認！")\n            return redirect(url_for(\'index\'))\n\n        if len(account_password) < 8:\n            flash("密碼長度必須至少 8 個字元！")\n            return redirect(url_for(\'index\'))\n\n        try:\n            result = create_user(prefix, account_password)\n            flash(f"帳號建立成功: {result[\'primaryEmail\']}")\n        except Exception as e:\n            flash(f"建立帳號失敗: {str(e)}")\n        return redirect(url_for(\'index\'))\n    return render_template(\'form.html\', user_email=user_email) \n templates/form.html \n <!doctype html>\n<title>建立 Google Workspace 帳號</title>\n<h2>建立 Google Workspace 帳號</h2>\n<p>目前登入：{{ user_email }}</p>\n<form method="POST">\n  <label>學號（Email @ 前）：<input type="text" name="prefix" required pattern="\\d+"></label><br>\n  <label>新帳號密碼：<input type="password" name="account_password" required></label><br>\n  <label>再次輸入密碼：<input type="password" name="confirm_password" required></label><br>\n  <input type="submit" value="送出">\n</form>\n{% with messages = get_flashed_messages() %}\n  {% if messages %}\n    <ul>\n    {% for message in messages %}\n      <li>{{ message }}</li>\n    {% endfor %}\n    </ul>\n  {% endif %}\n{% endwith %}\n<a href="{{ url_for(\'logout\') }}">登出</a> \n 另外新增一個 templates/not_allowed.html \n <!doctype html>\n<title>未授權訪問</title>\n<h2>未授權訪問</h2>\n<p>您的 email（{{ user_email }}）不在允許名單中，無法建立帳號。</p>\n<a href="{{ url_for(\'logout\') }}">登出</a> \n \n', 'tags': '', 'url': 'Waitress.html'}, {'title': 'API', 'text': '以下是「建立 Google Cloud Platform 專案並啟用 Admin SDK API」的詳細操作步驟，適用於管理 Google Workspace 的自動化應用： 一、建立 Google Cloud Platform (GCP) 專案 1. 登入 Google Cloud Console \xa0 \xa0前往 [Google Cloud Console]( https://console.cloud.google.com )。 2. 建立新專案 \xa0 \xa0- 點選左上角的「專案選單」下拉按鈕（通常會顯示你目前的專案名稱）。 \xa0 \xa0- 在彈出的專案視窗中，點選「新建專案」。 \xa0 \xa0- 輸入專案名稱（如：workspace-account-automation）。 \xa0 \xa0- 選擇對應的組織與資料夾（如有需要）。 \xa0 \xa0- 點選「建立」。 3. 切換到新專案 \xa0 \xa0- 專案建立完成後，點選右上角的「通知」可快速切換到新專案，或再次於專案選單中切換至新專案。 二、啟用 Admin SDK API and Gmail API 1. 進入 API 管理頁面 \xa0 \xa0- 確認你當前專案已切換至剛建立的專案。 \xa0 \xa0- 在左側導覽列，選擇「API 與服務」→「程式庫」。 2. 搜尋並啟用 Admin SDK \xa0 \xa0- 在搜尋框輸入 `Admin SDK`。 \xa0 \xa0- 點選搜尋結果中的「Admin SDK」。 \xa0 \xa0- 點選「啟用」。 \n \n \n 前往 Google Cloud Console：  👉  https://console.cloud.google.com/apis/library \n \n \n 搜尋並啟用對應 API，例如： \n \n \n Google Drive API \n \n \n Gmail API \n \n \n Google Sheets API 等 \n \n \n \n \n 三、（進階）建立並下載 Service Account 金鑰 \n https://console.cloud.google.com/iam-admin/serviceaccounts \xa0 \n ✅ 建立新的服務帳戶並啟用 Domain-wide Delegation \n 步驟： \n 🔁 建立一個新的 Service Account（在建立流程中會有「進階設定」） \n 🧭 詳細步驟如下： \n 1. 前往 [Google Cloud Console – Service Accounts](https://console.cloud.google.com/iam-admin/serviceaccounts) 2. 點選【建立服務帳戶】 3. 輸入服務帳戶名稱、ID、描述，點【建立並繼續】 4. 權限頁面可以直接點【繼續】 5. 第三步是「授予使用者訪問權限」：忽略它 ➝ 點【完成】 6. 建立完成後，回到該服務帳戶的詳細資料頁面 \n ✅ 啟用 Domain-wide Delegation： \n 1. 點你剛建立的服務帳戶名稱 2. 點選頁面上方的【Domain-wide Delegation】分頁 3. 按下【啟用網域範圍代理】按鈕 4. 填寫「產品名稱」（任意填即可，如：Workspace Bot） 5. 點【儲存】 \n 📌 完成後你會看到： \n * 一個 Client ID`（要貼去 Workspace 管理控制台使用） * 「View Google Workspace Admin Console」按鈕 \n ✅ 接著在 Workspace Admin Console 授權這個 Client ID \n 1. 登入 [admin.google.com](https://admin.google.com)（必須是超級管理員） 2. 前往：安全性 (Security) > Access and\xa0data control > API 控制權限 (API controls)> 網域範圍代理（Domain-wide delegation) > MANAGE DOMAIN WIDE DELEGATION 3. 點【新增】 4. 輸入你剛剛的 Client ID 5. 輸入你要授權的 OAuth scopes，例如： \n https://www.googleapis.com/auth/admin.directory.user https://www.googleapis.com/auth/admin.directory.group \n', 'tags': '', 'url': 'API.html'}, {'title': 'V', 'text': 'https://mde.tw/v/ \xa0 \n v.properties  for SciTE (將 V 程式碼存為 .v 後，在 SciTE 中以 Tools - Go 執行 v run 檔名.v) \n V Documentation \n v install pdf 之後， pdf 模組 在可攜系統將會位於\xa0Y:\\home_ipv6\\.vmodules \n https://github.com/vlang/vinix \xa0 \n https://github.com/vlang/ved \xa0 \n https://github.com/livewire/volt \xa0 \n https://github.com/elliotchance/vsql \xa0 \n https://github.com/vlang/gitly \xa0 \n https://github.com/vlang/vorum \xa0 \n V 語言的核心目標是「簡單、安全、高效」，並且特別適合用來開發高效的系統程式、嵌入式系統、CLI 工具等。它的設計理念是為了彌補 C 語言和 Rust 之間的差距，簡化開發過程，同時保持高效與安全。 \n \n \n 特點 ： \n \n \n 語法簡單，無需大量樣板代碼 ，學習曲線較平緩，適合開發快速原型。 \n \n \n 無垃圾回收（GC） ，記憶體管理方式可選擇手動或引用計數。 \n \n \n 支援  跨平台  編譯（Windows、Linux、macOS、WASM 等）。 \n \n \n 編譯速度極快 ，小型專案甚至可以在 1 秒內編譯完畢。 \n \n \n 使用  靜態類型系統 ，並強制編譯期檢查，避免空指標等錯誤。 \n \n \n 僅生成一個可執行檔，避免複雜的依賴和部署問題。 \n \n \n \n \n 設計理念 ：像 Go 語言一樣簡單，像 C 一樣高效，像 Rust 一樣安全，但更加簡化與直接，避免過多的樣板代碼和繁瑣的設置。 \n \n \n 未來發展性： \n V 語言的發展性仍在進行中，儘管它有一些非常有吸引力的特點，但由於它相對較新，目前仍面臨一些挑戰： \n \n \n 生態系統 ：目前的開發生態系統較小，缺乏許多現成的庫和框架。這對於大規模商業應用開發來說是一個障礙，但 V 語言的發展者已經在努力完善其生態系統。 \n \n \n 生產力與穩定性 ：儘管 V 語言設計上非常簡單，但實際運行的穩定性和性能在長期大規模使用中如何表現仍然需要觀察。 \n \n \n 市場接受度 ：Go 和 Rust 已經在市場中占有一席之地，V 的接受度可能需要時間。如果能夠快速吸引開發者社群並積極進行優化，未來仍然有可能在某些領域獲得一席之地，特別是在需要快速原型開發和高效編譯的場景中。 \n \n \n V 語言 是一個相對較新的程式語言，旨在彌補當前流行語言中的某些空白。與主流的編程語言（如  Go 、 Rust 、 C++ 、 Python  等）相比，V 有一些明顯的優勢，特別是在  簡單性、安全性  和  編譯速度  方面。但它的未來性仍然受到多方面挑戰，包括生態系統、社群支持、以及功能的深度等。 \n V 語言與現有熱門語言比較 \n \n 1.  V 語言 vs Go \n 優勢 ： \n \n \n 簡單性與語法 ：V 的語法非常簡單，沒有繁瑣的樣板代碼或其他語言常見的複雜結構（如 Go 的錯誤處理機制）。開發者可以像 Python 一樣輕鬆寫出簡潔的程式碼，而又能保有 C 語言般的性能。 \n \n \n 編譯速度 ：V 的編譯速度超快，通常小型專案在 1 秒內就能編譯完成。對比 Go，V 在這一點上有顯著的優勢，尤其是當開發者處於快速原型開發或需要迭代的情況下。 \n \n \n 無垃圾回收 ：V 沒有垃圾回收（GC），而 Go 使用垃圾回收機制。這使得 V 更適合一些對  記憶體控制  要求極高的應用，如嵌入式系統或高效能計算。 \n \n \n 安全性 ：V 強調 編譯時錯誤檢查 ，這使得許多錯誤可以在編譯階段就被捕捉。Go 的錯誤處理機制雖然簡單，但 缺乏像 V 一樣強制編譯期安全檢查 。 \n \n \n 挑戰 ： \n \n \n 生態系統與庫 ：Go 擁有龐大的生態系統和現成的庫，可以快速構建各類應用。相比之下，V 的生態系統仍在發展中，許多領域（如 Web 開發、機器學習等）仍然缺乏現成的庫和框架。 \n \n \n 並行性 ：Go 的  goroutines  是其最具代表性的特性，對於並行計算非常高效。V 雖然也支持併發，但其並行模型還不如 Go 成熟。 \n \n \n \n 2.  V 語言 vs Rust \n 優勢 ： \n \n \n 簡單性與學習曲線 ：Rust 的學習曲線比較陡峭，尤其是對記憶體管理的要求，V 語言則更加簡單。V 更容易上手，適合那些需要高效能但又不想為了記憶體安全而陷入過度複雜性的開發者。 \n \n \n 編譯速度 ：V 的編譯速度比 Rust 快得多。Rust 的編譯過程比較慢，特別是在大型專案中，這對開發者的效率是一個不小的挑戰。 \n \n \n 小型應用與原型開發 ：由於 V 的語法非常簡潔，編譯速度極快，因此它非常適合進行快速原型開發。Rust 雖然適合構建高性能系統，但對於快速原型和小型應用，V 可能會更高效。 \n \n \n 挑戰 ： \n \n \n 記憶體管理 ：Rust 以其 精確的記憶體管理 著稱，並且有 所有權模型 來防止內存錯誤（例如空指標、內存洩漏）。V 雖然沒有垃圾回收，但它的記憶體管理仍不如 Rust 精細，並且沒有像 Rust 那樣強大的所有權檢查。 \n \n \n 性能 ：Rust 被設計為極致高效，能與 C++ 相媲美。V 雖然在性能上不差，但在極限性能需求下，Rust 仍然占據領先地位。 \n \n \n \n 3.  V 語言 vs C++ \n 優勢 ： \n \n \n 簡單性 ：C++ 的語法比較冗長且容易出錯，需要大量樣板代碼，並且手動管理記憶體容易導致錯誤。V 則簡化了許多這些複雜的操作，像 Go 一樣注重簡潔的語法設計，能減少開發者的負擔。 \n \n \n 編譯速度 ：C++ 的編譯時間非常長，尤其在大型專案中，V 的快速編譯是一大優勢。 \n \n \n 安全性 ：C++ 允許使用指標運算，這使得它容易出現空指標和內存錯誤，而 V 語言則不允許這些操作，強制進行編譯時檢查以避免此類錯誤。 \n \n \n 挑戰 ： \n \n \n 性能 ：C++ 是目前最強大的系統編程語言之一，無論在內存控制還是處理速度上，C++ 都有極高的優勢。V 可能無法與 C++ 在極限性能上競爭，尤其是在需要  低層次硬體控制  或  高效能計算  的應用中。 \n \n \n 生態系統 ：C++ 的生態系統非常龐大，擁有大量的庫和工具支援，這是 V 無法在短期內超越的。 \n \n \n \n 4.  V 語言 vs Python \n 優勢 ： \n \n \n 性能 ：Python 雖然在開發效率上非常高，但它的執行速度比 V 慢得多，尤其是處理大量數據時，Python 的性能瓶頸非常明顯。而 V 能提供接近 C 的性能，適合高效能需求的應用。 \n \n \n 編譯速度與部署 ：Python 需要安裝解釋器並處理外部依賴，而 V 可以直接編譯成單一的原生可執行檔，這使得 V 在部署和運行效率上優於 Python。 \n \n \n 靜態型別與安全性 ：V 是靜態類型的，這意味著許多錯誤可以在編譯階段就被檢查出來，這比 Python 的動態類型安全性更高。 \n \n \n 挑戰 ： \n \n \n 生態系統與庫 ：Python 目前擁有非常龐大的生態系統，無論是 Web 開發、數據科學、機器學習還是自動化腳本，都有非常成熟的庫可供使用。V 的生態系統還處於起步階段，缺乏像 Python 一樣強大的第三方庫支持。 \n \n \n 開發效率 ：Python 是一個高度靈活的語言，開發速度非常快，對開發者非常友好。相比之下，V 雖然簡單，但還是比 Python 多了一些限制，並且其生態系統尚不完整。 \n \n \n \n 總結：V 語言的優勢與未來性 \n \n \n \n 語言 \n 優勢 \n 未來發展性 \n \n \n \n \n Go \n 簡單語法、高效編譯、無垃圾回收、快速原型開發 \n 仍需擴展庫和工具，與 Go 競爭的空間在於更強的安全性和編譯速度 \n \n \n Rust \n 簡單易學、編譯速度極快、內存控制精細 \n 開發速度快、跨平台部署、但功能不如 Rust 精細，未來可成為更輕量級的選擇 \n \n \n C++ \n 性能極高、深層系統控制 \n V 更簡單安全，但無法與 C++ 在極限性能上競爭，適合快速開發 \n \n \n Python \n 開發效率高、庫支持多 \n V 的高效性能可替代 Python 在處理大量數據時的瓶頸，但生態不如 Python 成熟 \n \n \n \n V 的未來性 取決於它是否能夠吸引到更多的開發者社群，並且發展出豐富的生態系統和第三方庫。隨著它在  系統開發  和  高效能應用  上的強大優勢，V 很有可能在這些領域獲得成功，但要成為類似 Python 或 Go 那樣的主流語言，還需要更長時間的發展。 \n', 'tags': '', 'url': 'V.html'}, {'title': 'learn_V', 'text': 'v_ex.7z \n gnuplot.7z \n Interview with the creator of V \n https://bitshifters.cc/2025/05/17/vlang.html \xa0 \n Review on V \n V Documentation \n Install from source code: \n git clone https://github.com/vlang/v cd v make # make.bat on Windows\xa0 \n 或直接從  github.com/vlang/v/release  下載 \n V 更新: \n v up \n 自行取下最新原始碼後，自行編譯 \n https://blog.vlang.io/getting-started-with-v / \n V by examples \n vweb tutorial \xa0( video ) \n https://github.com/malisipi/vwebui \xa0( https://github.com/webui-dev/v-webui ) \n https://webui.me/docs \xa0 \n https://labs.davlgd.fr/posts/2024-02-how-own-web-server-vlang/ \xa0 \n', 'tags': '', 'url': 'learn_V.html'}, {'title': 'Reeborg', 'text': 'https://mde.tw/cp2025/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1.py \n https://mde.tw/cp2025/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1_east_west.py \xa0 \n \n https://mde.tw/reeborg \n https://github.com/mdecycu/cs101 \n https://reeborg.ca/docs/en/python/index.html \n https://aroberge.github.io/reeborg-api/ \n if using local static port 9442: \n Reeborg \n For Github Pages: \n Reeborg \n \n', 'tags': '', 'url': 'Reeborg.html'}, {'title': 'ex1', 'text': 'https://mde.tw/cp2025/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1.py \xa0是已知的機器人採收紅蘿蔔的程式，經由以下與 Copilot 的對話，希望透過 Python Class 的編寫解決特定範圍農作物採收的程式。 \n 問句: \n 以下是 Reeborg 一個用來採收紅蘿蔔的程式, 目前位於 (3,3) 到 (8,8) 的區域中各座標點, 各有一個紅羅蔔等待採收, 現在想要建立一個 harvest() class, 可以利用 (3,3), (8,8)作為標定有農作物必須採收的兩個區域對角點座標, 而程式可以利用此一 harvest 類別生成案例完成採收的任務: def turn(int):\n    for i in range(int):\n        turn_left()\n        \ndef new_move(int):\n    for i in range(int):\n        move()\n        \ndef harvest_one_row():\n    while object_here():\n        take()\n    else:\n        move()\n# move to the field\nnew_move(2)\nturn_left()\nnew_move(2)\n\nfor i in range(3):\n    while is_facing_north():\n        for i in range(6):\n            harvest_one_row()\n        for i in range(2):\n            turn(3)\n            move() \n    else:\n        for i in range(6):\n            harvest_one_row()\n        for i in range(2):\n            turn_left()\n            move() \n AI 回答:\xa0 https://mde.tw/cp2025/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1_class_ex1.py \xa0 \n 進一步要求: \n 請在類別中加上一個採收方向的參數, 內建變數是 horizontal 採收, 也就是由西邊往東邊的水平方向進行採收, 但若該方向變數設為 vertical 則會由南邊往北的所謂垂直方向進行採收 \n AI 回應:\xa0 https://mde.tw/cp2025/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1_class_ex2.py\xa0 \xa0 \n 延伸到採收 harvest2 農田:\xa0 https://mde.tw/cp2025/reeborg/?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest2.json&editor=python/harvest1_class_ex1.py \xa0 \n 但卻沒能套用到 harvest3 農田:\xa0 https://mde.tw/cp2025/reeborg/?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest3.json&editor=python/harvest1_class_ex1.py \xa0 \n 而必須要在每一個座標點留下或放入一個紅蘿蔔:\xa0 https://mde.tw/cp2025/reeborg/?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest3.json&editor=python/harvest1_class_ex3.py\xa0 \xa0 \n', 'tags': '', 'url': 'ex1.html'}, {'title': 'Otto_ninja', 'text': 'https://www.printables.com/model/231580-otto-ninja-starter-robot/files \xa0 \n \n', 'tags': '', 'url': 'Otto_ninja.html'}, {'title': 'Brython', 'text': 'Brython  是一個將  Python  語法編譯為  JavaScript  的工具，能直接在瀏覽器中以  Python  撰寫前端網頁程式。 \n 1 add to 100 機器人巡邏 自由行 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  累加程式開始  \n \n  累加程式結束     機器人巡邏程式開始  \n \n  機器人巡邏程式結束  \n  機器人自由行程式開始  \n \n  機器人自由行程式結束  \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n', 'tags': '', 'url': 'Brython.html'}, {'title': 'Brython_ex', 'text': '機器人自由行 \n Can we bring pythonpad into this page?\xa0 https://pythonpad.github.io/docs/manual.html \xa0 \n from browser import document, html, timer\n \ncanvas = html.CANVAS(width=400, height=400)\nbrython_div = document["brython_div1"]\nbrython_div <= canvas\nctx = canvas.getContext("2d")\n \ndef draw_grid():\n    ctx.clearRect(0, 0, 400, 400)\n    ctx.strokeStyle = "#ccc"\n    ctx.lineWidth = 1\n    for i in range(0, 401, 40):\n        ctx.beginPath()\n        ctx.moveTo(i, 0)\n        ctx.lineTo(i, 400)\n        ctx.stroke()\n        ctx.beginPath()\n        ctx.moveTo(0, i)\n        ctx.lineTo(400, i)\n        ctx.stroke()\n    \n    # 畫出邊界\n    ctx.strokeStyle = "black"\n    ctx.lineWidth = 2\n    ctx.strokeRect(0, 0, 400, 400)\n\ndef draw_robot(x, y):\n    draw_grid()\n    ctx.fillStyle = "blue"\n    ctx.beginPath()\n    ctx.arc(x * 40 + 20, y * 40 + 20, 15, 0, 6.28)\n    ctx.fill()\n\nx, y = 0, 0\ndef move():\n    global x\n    x = (x + 1) % 10\n    draw_robot(x, y)\n\ndraw_grid()\ntimer.set_interval(move, 500) \n 以下程式, 按 j 隨箭頭方向前進, 按下 i 則左轉 \n from browser import document, html, bind\n\ncanvas = html.CANVAS(width=400, height=400)\nbrython_div = document["brython_div1"]\nbrython_div <= canvas\nctx = canvas.getContext("2d")\n\ncols, rows = 10, 10\ncell = 40\n\n# 上、右、下、左\ndirections = [(0, -1), (1, 0), (0, 1), (-1, 0)]\n\nrobot = {\n    "x": 5,\n    "y": 5,\n    "dir": 0  # 初始朝向上\n}\n\ndef draw_grid():\n    ctx.clearRect(0, 0, 400, 400)\n    ctx.strokeStyle = "#ccc"\n    ctx.lineWidth = 1\n    for i in range(0, 401, cell):\n        ctx.beginPath()\n        ctx.moveTo(i, 0)\n        ctx.lineTo(i, 400)\n        ctx.stroke()\n        ctx.beginPath()\n        ctx.moveTo(0, i)\n        ctx.lineTo(400, i)\n        ctx.stroke()\n    ctx.strokeStyle = "black"\n    ctx.lineWidth = 2\n    ctx.strokeRect(0, 0, 400, 400)\n\ndef draw_robot():\n    draw_grid()\n    cx = robot["x"] * cell + cell // 2\n    cy = robot["y"] * cell + cell // 2\n    size = 15\n    d = robot["dir"]\n\n    ctx.fillStyle = "blue"\n    ctx.beginPath()\n    if d == 0:  # 上\n        ctx.moveTo(cx, cy - size)\n        ctx.lineTo(cx - size, cy + size)\n        ctx.lineTo(cx + size, cy + size)\n    elif d == 1:  # 右\n        ctx.moveTo(cx + size, cy)\n        ctx.lineTo(cx - size, cy - size)\n        ctx.lineTo(cx - size, cy + size)\n    elif d == 2:  # 下\n        ctx.moveTo(cx, cy + size)\n        ctx.lineTo(cx - size, cy - size)\n        ctx.lineTo(cx + size, cy - size)\n    elif d == 3:  # 左\n        ctx.moveTo(cx - size, cy)\n        ctx.lineTo(cx + size, cy - size)\n        ctx.lineTo(cx + size, cy + size)\n    ctx.closePath()\n    ctx.fill()\n\n@bind(document, "keydown")\ndef on_key(e):\n    key = e.key.lower()\n    if key == "i":\n        robot["dir"] = (robot["dir"] - 1) % 4  # 左轉\n    elif key == "j":\n        dx, dy = directions[robot["dir"]]\n        nx = robot["x"] + dx\n        ny = robot["y"] + dy\n        if 0 <= nx < cols and 0 <= ny < rows:\n            robot["x"] = nx\n            robot["y"] = ny\n    draw_robot()\n\ndraw_robot() \n Optimization: \n 題目: 一位製造商想設計一個開口式的盒子，其底部為長方形，寬為 x、長為 y，且總表面積為 80 平方公分。 請問要使盒子的體積達到最大，應該選用哪些尺寸？ \n 直接利用 Python 以  Differential Evoluation  運算:\xa0 de_volume_max.py \n 參考:\xa0 \n de_volume_max.c ,\xa0 de_volume_max.v \n 也可以採網頁前端使用 Brython，後端採 Python 執行運算後將資料傳回網頁:\xa0 brython_w_flask.7z \n', 'tags': '', 'url': 'Brython_ex.html'}, {'title': 'Brython1', 'text': '將  brython_robot.py  放入 downloads/py 目錄，此 Brython 程式庫將會再啟動 Brython 頁面環境時導入，使用者就可以直接利用  brython1_ex1.py  控制機器人，也可以自行擴充定義  turn_right()  函式。 \n 也可以利用 i、m、j、k 等四個鍵控制 robot 向前、後退、左轉與右轉:  brython1_ijkm_control.py 。 \n 1 add to 100 機器人巡邏 自由行 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  累加程式開始  \n \n  累加程式結束     機器人巡邏程式開始  \n \n  機器人巡邏程式結束  \n  機器人自由行程式開始  \n \n  機器人自由行程式結束  \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n', 'tags': '', 'url': 'Brython1.html'}, {'title': 'Brython2', 'text': '若將  brython_robot2.py  放進 download/py 目錄中，使用者可以延伸執行  brython_robot2_ex1.py ,  結果 。 \n 也能執行  brython_robot2_ex2.py ,  結果 。 \n brython_robot2_ex3.py ,  結果 。 \n brython_robot2_ex4.py ,  結果 。(按下 i 鍵左轉，按下 j 鍵向前走一步，按下 p 鍵可以採收，每次最多採收 5 個農作物) \n brython_robot2_ex5.py ,  結果 。(可透過 buttons 操控) \n brython_robot2_ex6.py ,  結果 。(每 5 個紅蘿蔔裝一盒，裝盒前個數標示在右上方，採收盒數標示在左上方) \n 1 add to 100 機器人巡邏 自由行 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  累加程式開始  \n \n  累加程式結束     機器人巡邏程式開始  \n \n  機器人巡邏程式結束  \n  機器人自由行程式開始  \n \n  機器人自由行程式結束  \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n', 'tags': '', 'url': 'Brython2.html'}, {'title': 'Pyodide', 'text': 'Pyodide  是一個將  Python  解譯器和常用科學套件 (例如:  numpy 、 scipy 、 matplotlib \xa0等) 編譯成  WebAssembly ，可在瀏覽器中執行  Python \xa0程式的專案。 \n Pyodide  是將  CPython  編譯為  WebAssembly ，可在瀏覽器或其他  WebAssembly  環境中執行；而  CPython  是標準的原生  Python  解譯器，運行在作業系統上。換言之， Pyodide  是為在瀏覽器中執行  Python  而設計的  CPython  移植版本。 Pyodide \xa0可與  JavaScript  雙向互動，讓  Python  程式能呼叫  JavaScript  函數並操作網頁元素，也能被  JavaScript  呼叫執行  Python  程式碼。 \n \n version   hello   1 add to 100   機器人巡邏 自由行   numpy_ode \n  Ace Editor Scripts  \n \n \n \n \n \n \n  Editor 1  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n 從 1 累加到 100 part2: \n 1 add to 100 \n  Editor 2  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n', 'tags': '', 'url': 'Pyodide.html'}, {'title': 'Pyodide_ex', 'text': 'Pyodide 機器人巡邏 \xa0- 由於網頁載入場景圍牆與 Pyodide 執行機器人行走模擬的速度差異，機器人巡邏畫面的圍牆無法及時顯示。 \n 經過場景圍牆多次 (目前為 3 次) 載入 (必須配合瀏覽器 Client 端執行速度與網路傳輸速度進行調整)， Pyodide 機器人巡邏2  可以正確載入圍牆圖檔。 \n Pyodide 導入客製化模組: \n const code = `\n# 定義一個模組內容\ndef hello():\n    print("Hello from custom module!")\n`;\npyodide.runPython(code);\n \n Volume_max_pyodide_de_short.py \n Volume_max_pyodide_de.py \n', 'tags': '', 'url': 'Pyodide_ex.html'}, {'title': 'Pyodide2', 'text': 'Pyodide2 在頁面中導入  robot.py \xa0(註解版:  pyodide_robot_commented.py ) 後，可以直接在頁面編輯器中，直接利用 walk() 與 turn_left() 兩個方法，引導 機器人前行與左轉 。也可以在編輯器中自行 定義右轉方法 ，賦予機器人更多功能。 \n \n \n \n version   hello   1 add to 100   機器人巡邏   自由行   numpy_ode \n  Ace Editor Scripts  \n \n \n \n \n \n \n \n \n  Editor 1  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n 從 1 累加到 100 part2: \n 1 add to 100 \n  Editor 2  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n \n', 'tags': '', 'url': 'Pyodide2.html'}, {'title': 'robot.py', 'text': 'robot.py \n 第一段：模組匯入與常數定義 \n js 是 Brython 提供的 JS-Python 橋接模組，可直接操作 JavaScript DOM。 asyncio 是 Python 的非同步處理模組，用來讓動畫非同步進行。 CELL_SIZE 設定地圖中每個格子的大小（40px × 40px）。 WALL_THICKNESS 是用於繪製牆壁的線條厚度。 IMG_PATH 是儲存所有圖片的伺服器路徑（用於載入牆壁與機器人圖）。 \n import js, asyncio\n\n# 每個格子的像素寬度\nCELL_SIZE = 40\n\n# 牆壁的厚度（像素）\nWALL_THICKNESS = 6\n\n# 圖片資源的網址前綴\nIMG_PATH = "https://mde.tw/cp2025/reeborg/src/images/"\n \n 第二段：World 類別 – 建立世界與地圖圖層 \n World 類負責建立整個地圖畫面，並初始化所需的畫布圖層。 _image_cache 是類別層級變數，用來快取圖片物件。 \n class World:\n    _image_cache = {}  # 用來暫存載入過的圖片，避免重複下載\n\n    def __init__(self, width, height):\n        self.width = width     # 地圖寬（幾格）\n        self.height = height   # 地圖高（幾格）\n        self.layers = self._create_layers()  # 建立四個 canvas 圖層\n        self._init_html()      # 將圖層與控制按鈕加到 HTML 畫面\n \n 第三段：建立圖層 \n 這些圖層都是 canvas 元素，彼此重疊在一起，依序繪製地圖。 \n     def _create_layers(self):\n        return {\n            "grid": js.document.createElement("canvas"),    # 網格底圖\n            "walls": js.document.createElement("canvas"),   # 牆壁\n            "objects": js.document.createElement("canvas"), # 痕跡/物件\n            "robots": js.document.createElement("canvas"),  # 機器人\n        }\n \n 第四段：初始化 HTML 結構 \n 建立一個 container 容器，設定為相對定位。 將四層 canvas 疊放進容器中，每層用不同的 zIndex 疊層排序。 \n     def _init_html(self):\n        container = js.document.createElement("div")\n        container.style.position = "relative"\n        container.style.width = f"{self.width * CELL_SIZE}px"\n        container.style.height = f"{self.height * CELL_SIZE}px"\n\n        for z, canvas in enumerate(self.layers.values()):\n            canvas.width = self.width * CELL_SIZE\n            canvas.height = self.height * CELL_SIZE\n            canvas.style.position = "absolute"\n            canvas.style.top = "0px"\n            canvas.style.left = "0px"\n            canvas.style.zIndex = str(z)\n            container.appendChild(canvas)\n \n 第五段：建立控制按鈕並加入畫面 \n 建立兩個按鈕：「前進」與「左轉」。 設定美觀的樣式（內邊距、字體大小等）。 \n         button_container = js.document.createElement("div")\n        button_container.style.marginTop = "10px"\n        button_container.style.textAlign = "center"\n\n        move_button = js.document.createElement("button")\n        move_button.innerHTML = "Move Forward"\n        move_button.style.margin = "5px"\n        move_button.style.padding = "10px 20px"\n        move_button.style.fontSize = "16px"\n        button_container.appendChild(move_button)\n\n        turn_button = js.document.createElement("button")\n        turn_button.innerHTML = "Turn Left"\n        turn_button.style.margin = "5px"\n        turn_button.style.padding = "10px 20px"\n        turn_button.style.fontSize = "16px"\n        button_container.appendChild(turn_button)\n \n \xa0第六段：掛載進 HTML 與按鈕綁定 \n 將畫面掛載到 HTML 中的 brython_div1 元素內。 同時記錄兩個按鈕到 self.move_button、self.turn_button 屬性，以便之後綁定事件 \n         brython_div = js.document.getElementById("brython_div1")\n        if not brython_div:\n            raise RuntimeError("🚨 \'brython_div1\' element not found in HTML!")\n        brython_div.innerHTML = ""\n        brython_div.appendChild(container)\n        brython_div.appendChild(button_container)\n\n        self.move_button = move_button\n        self.turn_button = turn_button\n \n 第七段：繪製地圖網格線（grid） \n 這段程式會畫出地圖的格線，形成棋盤狀的網格。 每格大小為 CELL_SIZE = 40 像素。 格線只是視覺輔助，沒有碰撞作用。 \n     def _draw_grid(self):\n        ctx = self.layers["grid"].getContext("2d")  # 取得網格圖層的繪圖上下文\n        ctx.strokeStyle = "#cccccc"  # 設定線條顏色為淡灰色\n\n        # 垂直線（每列格線）\n        for i in range(self.width + 1):\n            ctx.beginPath()\n            ctx.moveTo(i * CELL_SIZE, 0)\n            ctx.lineTo(i * CELL_SIZE, self.height * CELL_SIZE)\n            ctx.stroke()\n\n        # 水平線（每欄格線）\n        for j in range(self.height + 1):\n            ctx.beginPath()\n            ctx.moveTo(0, j * CELL_SIZE)\n            ctx.lineTo(self.width * CELL_SIZE, j * CELL_SIZE)\n            ctx.stroke()\n \n 第八段：通用繪圖函式 _draw_image() \n 此函式負責畫圖片在指定格子位置。 需要傳入： \xa0 \xa0 ctx: 要繪製的畫布上下文。 \xa0 \xa0 img_key: 要畫的圖片鍵（例如 "blue_robot_e"）。 \xa0 \xa0 (x, y): 要畫在哪個格子（以地圖邏輯座標為主）。 \xa0 \xa0 (w, h): 圖片的寬與高。 會自動調整畫面位置，將 y 軸上下反轉，使原點在左下角。 \n     def _draw_image(self, ctx, img_key, x, y, w, h, offset_x=0, offset_y=0):\n        img = World._image_cache.get(img_key)\n        if img and img.complete and img.naturalWidth > 0:\n            px = x * CELL_SIZE + offset_x\n            py = (self.height - 1 - y) * CELL_SIZE + offset_y\n            ctx.drawImage(img, px, py, w, h)\n            return True\n        else:\n            print(f"⚠️ Image \'{img_key}\' not ready for drawing.")\n            return False\n \n 第九段：繪製牆壁 _draw_walls() \n 這段會將四周的「邊界牆」畫出來。 利用 _draw_image 畫出 north.png 與 east.png。 offset_x / offset_y 用來對齊圖片位置（不會蓋到格子內）。 \n     async def _draw_walls(self):\n        ctx = self.layers["walls"].getContext("2d")\n        ctx.clearRect(0, 0, self.width * CELL_SIZE, self.height * CELL_SIZE)\n        success = True\n\n        # 繪製上下兩排的北牆（頂部與底部）\n        for x in range(self.width):\n            success &= self._draw_image(ctx, "north", x, self.height - 1, CELL_SIZE, WALL_THICKNESS, offset_y=0)\n            success &= self._draw_image(ctx, "north", x, 0, CELL_SIZE, WALL_THICKNESS, offset_y=CELL_SIZE - WALL_THICKNESS)\n\n        # 繪製左右兩側的東牆（左邊與右邊）\n        for y in range(self.height):\n            success &= self._draw_image(ctx, "east", 0, y, WALL_THICKNESS, CELL_SIZE, offset_x=0)\n            success &= self._draw_image(ctx, "east", self.width - 1, y, WALL_THICKNESS, CELL_SIZE, offset_x=CELL_SIZE - WALL_THICKNESS)\n\n        return success\n \n 第十段：預先載入圖片 _preload_images() \n 此函式會載入所有需要用到的圖片（牆壁與機器人朝向圖）。 利用 Promise 建立圖片載入完成的非同步事件，確保載入成功。 透過 await js.await_promise(js.Promise.all(...)) 等待所有圖片載入完畢。 \n     async def _preload_images(self):\n        image_files = {\n            "blue_robot_e": "blue_robot_e.png",\n            "blue_robot_n": "blue_robot_n.png",\n            "blue_robot_w": "blue_robot_w.png",\n            "blue_robot_s": "blue_robot_s.png",\n            "north": "north.png",\n            "east": "east.png",\n        }\n\n        promises = []\n        for key, filename in image_files.items():\n            if key in World._image_cache and World._image_cache[key].complete:\n                continue\n\n            img = js.document.createElement("img")\n            img.crossOrigin = "Anonymous"\n            img.src = IMG_PATH + filename\n            World._image_cache[key] = img\n\n            def make_promise(img_element):\n                def executor(resolve, reject):\n                    def on_load(event):\n                        img_element.removeEventListener("load", on_load)\n                        img_element.removeEventListener("error", on_error)\n                        resolve(img_element)\n                    def on_error(event):\n                        img_element.removeEventListener("load", on_load)\n                        img_element.removeEventListener("error", on_error)\n                        reject(f"Failed to load image: {img_element.src}")\n                    img_element.addEventListener("load", on_load)\n                    img_element.addEventListener("error", on_error)\n                    if img_element.complete and img_element.naturalWidth > 0:\n                        resolve(img_element)\n                return js.Promise.new(executor)\n\n            promises.append(make_promise(img))\n\n        if not promises:\n            return True\n        try:\n            await js.await_promise(js.Promise.all(promises))\n            return True\n        except Exception as e:\n            print(f"🚨 Error during image preloading: {str(e)}")\n            return False\n \n 第十一段：初始化地圖與資源 setup() \n setup() 是建構完世界後必須呼叫的初始化函式。 包含資源載入、地圖格線與牆壁的繪製。 使用 asyncio.sleep(0) 是一種「讓出主控權給瀏覽器」的技巧，避免卡住畫面。 \n     async def setup(self):\n        # 嘗試三次載入圖片資源，若載入成功則跳出迴圈\n        for _ in range(3):\n            if await self._preload_images():\n                break\n            await asyncio.sleep(0.5)  # 等待 0.5 秒後再試\n        else:\n            print("🚨 Failed to preload images after retries.")\n            return False\n\n        await asyncio.sleep(0)  # 放棄當前事件迴圈執行權，確保 UI 有機會更新\n\n        self._draw_grid()  # 繪製底層的網格\n\n        # 嘗試三次繪製牆壁，等待圖片載入完成\n        for _ in range(3):\n            if await self._draw_walls():\n                break\n            await asyncio.sleep(0.5)\n        else:\n            print("🚨 Failed to draw walls after retries.")\n            return False\n\n        # 最後確認機器人朝向東的圖片是否可用\n        robot_img_key = "blue_robot_e"\n        if not (World._image_cache.get(robot_img_key) and World._image_cache[robot_img_key].complete):\n            print(f"🚨 Robot image \'{robot_img_key}\' still not ready after setup!")\n            return False\n\n        return True  # 所有步驟成功後回傳 True\n \n 第十二段：機器人類別 Robot \n 每個 Robot 物件都有座標與面向，並能畫出自己與移動的軌跡。 傳入 world 是為了能取得地圖的畫布資訊。 \n class Robot:\n    def __init__(self, world, x, y):\n        self.world = world\n        self.x = x - 1  # 將人類習慣的 1-index 轉成 0-index\n        self.y = y - 1\n        self.facing = "E"  # 預設朝東（右邊）\n        self._facing_order = ["E", "N", "W", "S"]  # 左轉時的順序\n\n        self.robot_ctx = world.layers["robots"].getContext("2d")   # 機器人圖層\n        self.trace_ctx = world.layers["objects"].getContext("2d")  # 移動軌跡圖層\n\n        self._draw_robot()  # 初始畫上機器人\n \n _robot_image_key()：依面向回傳圖片鍵 \n 根據面向回傳對應的圖片鍵，例如  E  會回傳  "blue_robot_e" 。 \n     def _robot_image_key(self):\n        return f"blue_robot_{self.facing.lower()}"\n \n _draw_robot()：畫出機器人圖像 \n 先清除原圖，避免留下殘影，再畫上新的機器人圖像。 \n     def _draw_robot(self):\n        self.robot_ctx.clearRect(0, 0, self.world.width * CELL_SIZE, self.world.height * CELL_SIZE)\n        self.world._draw_image(self.robot_ctx, self._robot_image_key(), self.x, self.y, CELL_SIZE, CELL_SIZE)\n \n _draw_trace()：畫出移動路徑 \n 此方法畫出機器人從起點到終點的直線軌跡。 \n     def _draw_trace(self, from_x, from_y, to_x, to_y):\n        ctx = self.trace_ctx\n        ctx.strokeStyle = "#d33"  # 紅色線條\n        ctx.lineWidth = 2\n        ctx.beginPath()\n        fx = from_x * CELL_SIZE + CELL_SIZE / 2\n        fy = (self.world.height - 1 - from_y) * CELL_SIZE + CELL_SIZE / 2\n        tx = to_x * CELL_SIZE + CELL_SIZE / 2\n        ty = (self.world.height - 1 - to_y) * CELL_SIZE + CELL_SIZE / 2\n        ctx.moveTo(fx, fy)\n        ctx.lineTo(tx, ty)\n        ctx.stroke()\n \n 第十三段：機器人行走與轉彎 \n walk(steps)：前進 \n 根據面向方向更新位置，並畫出移動。 超出地圖邊界時停止。 \n     async def walk(self, steps=1):\n        for _ in range(steps):\n            from_x, from_y = self.x, self.y\n            dx, dy = 0, 0\n            if self.facing == "E": dx = 1\n            elif self.facing == "W": dx = -1\n            elif self.facing == "N": dy = 1\n            elif self.facing == "S": dy = -1\n\n            next_x = self.x + dx\n            next_y = self.y + dy\n\n            if 0 <= next_x < self.world.width and 0 <= next_y < self.world.height:\n                self.x, self.y = next_x, next_y\n                self._draw_trace(from_x, from_y, self.x, self.y)\n                self._draw_robot()\n                await asyncio.sleep(0.2)\n            else:\n                print("🚨 Hit a wall, stop moving!")\n                break\n \n turn_left()：左轉 \n 從目前面向向左轉一格，更新圖片。 \n     async def turn_left(self):\n        idx = self._facing_order.index(self.facing)\n        self.facing = self._facing_order[(idx + 1) % 4]  # 循環轉向\n        self._draw_robot()\n        await asyncio.sleep(0.3)\n \n 第十四段：綁定控制 _bind_controls(robot) \n 定義一個私有方法，將控制行為綁定給特定 robot 實例。 \n def _bind_controls(robot: Robot):\n \n 鍵盤控制 \n 設定 j → 前進，i → 左轉。 使用 asyncio.create_task() 以非同步方式執行，避免卡住主執行緒。 \n     def handle_key(event):\n        try:\n            if event.key == \'j\':\n                asyncio.create_task(robot.walk(1))     # 按下 j 移動一步\n            elif event.key == \'i\':\n                asyncio.create_task(robot.turn_left()) # 按下 i 左轉\n        except Exception as e:\n            print(f"🚨 Error in key handler: {e}")\n \n 按鈕點擊控制 \n 這兩個函式綁定到 UI 裡的按鈕（前面 _init_html() 中定義的）。 功能與鍵盤控制一樣，只是透過滑鼠點擊。 \n     def handle_move_button(event):\n        try:\n            asyncio.create_task(robot.walk(1))\n        except Exception as e:\n            print(f"🚨 Error in move button handler: {e}")\n\n    def handle_turn_button(event):\n        try:\n            asyncio.create_task(robot.turn_left())\n        except Exception as e:\n            print(f"🚨 Error in turn button handler: {e}")\n \n 註冊事件到 JavaScript \n 將 handle_key() 註冊為全域 py_handle_key，讓 JavaScript 層級可以呼叫 Python。 \n 將按鈕的點擊事件對應到 Python 定義的控制函式。 \n     js.window.py_handle_key = handle_key\n    js.document.addEventListener(\'keydown\', js.Function("event", "py_handle_key(event);"))\n    js.window.py_handle_move_button = handle_move_button\n    js.window.py_handle_turn_button = handle_turn_button\n    robot.world.move_button.addEventListener(\'click\', js.Function("event", "py_handle_move_button(event);"))\n    robot.world.turn_button.addEventListener(\'click\', js.Function("event", "py_handle_turn_button(event);")) \n 第十五段：初始化並啟動 init() \n 提供一個使用者簡單快速初始化整個世界與機器人的介面。 \n def init(world_width=10, world_height=10, robot_x=1, robot_y=1):\n \n 包裝為非同步任務 \n 這個包裝函式 async def _inner() 是用來實作內部非同步邏輯。 \n     async def _inner():\n        world = World(world_width, world_height)  # 建立世界\n        if not await world.setup():               # 等待世界初始化完成\n            raise RuntimeError("World setup failed!")  # 若失敗則丟出錯誤\n\n        robot = Robot(world, robot_x, robot_y)    # 建立機器人\n        _bind_controls(robot)                     # 綁定控制事件\n        return world, robot                       # 傳回 world 和 robot 物件\n \n 建立並啟動非同步任務 \n     return asyncio.create_task(_inner())\n \n 回傳一個非同步任務（asyncio.Task），讓使用者可以這樣呼叫： \n world, robot = await init(10, 10, 1, 1)\n \n 等待 init() 的結果後，就可以直接控制 robot.walk() 或 robot.turn_left()。 \n', 'tags': '', 'url': 'robot.py.html'}, {'title': 'Example2', 'text': '自行定義機器人右轉的非同步執行函式: \n 執行 turn_right 程式 範例。 \n import robot\nimport asyncio\n\n# 定義右轉的非同步函式\nasync def turn_right(bot):\n    for _ in range(3):\n        await bot.turn_left()\n\nasync def main():\n    world, bot = await robot.init(10, 10, 1, 1)\n    print("機器人開始行動")\n    await bot.turn_left()\n    await bot.walk(9)\n    await turn_right(bot) \n    print("機器人完成行動")\n\n# main() 讓出執行控制權，由頁面中的 even loop 決定何時執行 main()\nawait main()\n \n', 'tags': '', 'url': 'Example2.html'}, {'title': 'Pyodide3', 'text': 'Pyodide3 則在  Pyodide  與  Pyodide2  頁面架構下，進一步導入  robot_w_world.py ，在既有的水平圍牆  north.png  與垂直圍牆  east.png  檔案之外，加入  carrot.png 、 grass.png  與  pale_grass.png  等圖檔。並且擴充可從 URL 讀進 json 格式的 world 變數功能，以便製作出更多元的場景任務，要求機器人執行。 \n 其中 src URL 變數，可以將網路上的機器人控制程式導入 Pyodide3 頁面外，world URL 變數則可以導入源自  Reeborg  機器人程式所設定的 json 格式場景。 \n 由於 Reeborg 系統中的 png 圖檔均非透明背景， robot_w_world.py \xa0必須利用 HTML 中的 CANVAS，將關鍵的白色背景，以透明的方式顯示。 \n src URL 變數讀進  turn_right 程式 ，而 world URL 變數則讀進  harvest2.json ，執行 結果 。 \n 讀進  harvest3.json , 執行 結果 。 \n \n \n \n version   hello   1 add to 100   機器人巡邏   自由行   numpy_ode \n  Ace Editor Scripts  \n \n \n \n \n \n \n \n \n  Editor 1  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n 從 1 累加到 100 part2: \n 1 add to 100 \n  Editor 2  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n \n', 'tags': '', 'url': 'Pyodide3.html'}, {'title': 'png_files', 'text': '利用  robot_w_world.py  將 png 圖檔實踐「關鍵色透明」: 作法是在程式碼中額外添加像素處理的邏輯。Canvas 的 drawImage 方法本身不會自動識別並跳過特定顏色的像素，所以我們必須手動介入。 處理方法: 要讓  robot_w_world.py  實現這個功能，必須修改 _draw_image 方法，或者在圖片載入後進行預處理。最直接的方法是在繪製數字圖片時，讀取其像素數據，並將特定顏色（例如白色）的像素的 Alpha 值設置為 0。 這會涉及以下步驟： \xa0 \xa0 取得圖片像素資料： 將圖片繪製到一個臨時的、看不見的 Canvas 上。 \xa0 \xa0 讀進所有像素： 讀取這個臨時 Canvas 的像素資料。 \xa0 \xa0 修改像素的 Alpha 值： 檢查每個像素的 RGB 值，如果它符合預設的「關鍵色」（例如，純白色 (255, 255, 255)），就將其 Alpha (透明度) 值設為 0。 \xa0 \xa0 將修改後的像素資料放回： 將修改後的像素資料重新放回臨時 Canvas。 \xa0 \xa0 繪製臨時 Canvas： 最後，將這個處理過的臨時 Canvas 繪製到我們實際要顯示的圖層上。 缺點與考量: \xa0 \xa0 性能影響： 像素級的處理是相對耗費資源的，特別是當有很多數字需要顯示時。這可能會導致動畫或初始加載時出現輕微的延遲。 \xa0 \xa0 複雜性增加： 程式碼會變得更複雜，需要處理 Canvas API 的 getImageData 和 putImageData 方法。 \xa0 \xa0 關鍵色選擇： 您需要確定一個所有數字圖片背景都一致的「關鍵色」。如果有些數字圖片背景是白色，有些是淺灰色，這個方法就會失效。 \n', 'tags': '', 'url': 'png_files.html'}, {'title': 'Harvest', 'text': 'Pyodide3  在頁面中導入  robot_w_world.py \xa0後，可以透過\xa0 pyodide3_harvest_ex1.py \xa0繼承 robot 物件，加入農作物採收功能。 \n 但因為\xa0 robot_w_world.py \xa0版本中的 trace 繪製圖層並未獨立，除了採收農作物之後的座標背景會從 pale_grass.png 置換為 grass.png 外，農作物採收後的座標畫面刷新會一併將之前的機器人行走路徑刪除，因此後續版本必須將所有不同屬性的圖像，以各自的獨立圖層進行繪製，才不會互相影響下，產生錯誤的機器人農作物採收模擬。 \n 在 Pyodide3 執行\xa0 pyodide3_harvest_ex1.py ，執行 結果 。 \n', 'tags': '', 'url': 'Harvest.html'}]};