import js, asyncio

CELL_SIZE = 40
WALL_THICKNESS = 6
IMG_PATH = "https://mde.tw/cp2025/reeborg/src/images/"
WIDTH, HEIGHT = 10, 10

container = js.document.getElementById("brython_div1")
container.innerHTML = ""
container.style.position = "relative"
container.style.width = f"{WIDTH * CELL_SIZE}px"
container.style.height = f"{HEIGHT * CELL_SIZE}px"

def create_canvas_layer(z):
    c = js.document.createElement("canvas")
    c.width = WIDTH * CELL_SIZE
    c.height = HEIGHT * CELL_SIZE
    c.style.position = "absolute"
    c.style.top = "0px"
    c.style.left = "0px"
    c.style.zIndex = str(z)
    container.appendChild(c)
    return c

layers = {
    "grid": create_canvas_layer(0),
    "walls": create_canvas_layer(1),
    "objects": create_canvas_layer(2),
    "robots": create_canvas_layer(3),
}
ctx_grid = layers["grid"].getContext("2d")
ctx_walls = layers["walls"].getContext("2d")
ctx_objs = layers["objects"].getContext("2d")
ctx_robots = layers["robots"].getContext("2d")

# --- Global dictionary to cache loaded robot images ---
# This will store the loaded Image objects for reuse.
robot_image_cache = {}

async def preload_robot_images():
    """Preloads all robot images into the cache."""
    directions = ["e", "n", "w", "s"]
    promises = []

    for direction in directions:
        img = js.document.createElement("img")
        img.src = IMG_PATH + f"blue_robot_{direction}.png"
        
        # Create a Promise that resolves when the image is loaded
        # This uses js.Promise.new to create a JavaScript Promise,
        # which Pyodide's asyncio can await via js.await_promise.
        load_promise = js.Promise.new(lambda resolve, reject: 
            img.addEventListener("load", lambda evt: resolve(img)),
            img.addEventListener("error", lambda evt: reject(js.Error.new(f"Failed to load image: {img.src}")))
        )
        promises.append(load_promise)
        # Store the img object in the cache *before* awaiting, so it persists
        robot_image_cache[direction] = img 

    try:
        # Await all image loading promises
        await js.await_promise(js.Promise.all(promises))
        print("‚úÖ All robot images preloaded successfully!")
    except Exception as e:
        print(f"üö® Error preloading robot images: {e}")
        # If preloading fails, the robot won't appear, but the grid/walls/trace should still work.

# --- Original draw_grid and draw_walls (remain unchanged) ---
def draw_grid():
    ctx_grid.strokeStyle = "#cccccc"
    for i in range(WIDTH + 1):
        ctx_grid.beginPath()
        ctx_grid.moveTo(i * CELL_SIZE, 0)
        ctx_grid.lineTo(i * CELL_SIZE, HEIGHT * CELL_SIZE)
        ctx_grid.stroke()
    for j in range(HEIGHT + 1):
        ctx_grid.beginPath()
        ctx_grid.moveTo(0, j * CELL_SIZE)
        ctx_grid.lineTo(WIDTH * CELL_SIZE, j * CELL_SIZE)
        ctx_grid.stroke()

def draw_walls():
    def draw_img(ctx, src, x, y, w, h, offx=0, offy=0):
        img = js.document.createElement("img")
        img.src = src
        def onload(evt):
            px = x * CELL_SIZE + offx
            py = (HEIGHT - 1 - y) * CELL_SIZE + offy
            ctx.drawImage(img, px, py, w, h)
        img.addEventListener("load", onload)
    for x in range(WIDTH):
        draw_img(ctx_walls, IMG_PATH+"north.png", x, HEIGHT-1, CELL_SIZE, WALL_THICKNESS)
        draw_img(ctx_walls, IMG_PATH+"north.png", x, 0, CELL_SIZE, WALL_THICKNESS, offy=CELL_SIZE - WALL_THICKNESS)
    for y in range(HEIGHT):
        draw_img(ctx_walls, IMG_PATH+"east.png", 0, y, WALL_THICKNESS, CELL_SIZE)
        draw_img(ctx_walls, IMG_PATH+"east.png", WIDTH-1, y, WALL_THICKNESS, CELL_SIZE, offx=CELL_SIZE - WALL_THICKNESS)

# Call these sync functions early, as they were working previously
draw_grid()
draw_walls()

class AnimatedRobot:
    def __init__(self, x, y):
        self.x = x - 1
        self.y = y - 1
        self.facing = "E"
        self.order = ["E", "N", "W", "S"]
        self.draw_robot() # Initial draw

    def draw_robot(self):
        ctx_robots.clearRect(0, 0, WIDTH * CELL_SIZE, HEIGHT * CELL_SIZE)
        
        # Get the correct preloaded image from the cache
        robot_img = robot_image_cache.get(self.facing.lower())
        
        if robot_img and robot_img.complete: # Ensure it's in cache and fully loaded
            px = self.x * CELL_SIZE
            py = (HEIGHT - 1 - self.y) * CELL_SIZE
            ctx_robots.drawImage(robot_img, px, py, CELL_SIZE, CELL_SIZE)
        else:
            # This should ideally not happen if preload_robot_images succeeds
            print(f"‚ö†Ô∏è Robot image for direction '{self.facing}' not yet loaded or found in cache.")

    def draw_trace(self, fx, fy, tx, ty):
        ctx_objs.strokeStyle = "#d33"
        ctx_objs.lineWidth = 2
        ctx_objs.beginPath()
        ctx_objs.moveTo(fx*CELL_SIZE+CELL_SIZE/2, (HEIGHT-1-fy)*CELL_SIZE+CELL_SIZE/2)
        ctx_objs.lineTo(tx*CELL_SIZE+CELL_SIZE/2, (HEIGHT-1-ty)*CELL_SIZE+CELL_SIZE/2)
        ctx_objs.stroke()

    async def move(self, steps):
        for _ in range(steps):
            fx, fy = self.x, self.y
            if self.facing == "E": dx, dy = 1, 0
            elif self.facing == "W": dx, dy = -1, 0
            elif self.facing == "N": dx, dy = 0, 1
            else: dx, dy = 0, -1
            nx, ny = self.x + dx, self.y + dy
            if 0 <= nx < WIDTH and 0 <= ny < HEIGHT:
                self.x, self.y = nx, ny
                self.draw_trace(fx, fy, nx, ny)
                self.draw_robot() # This is now a synchronous call
                await asyncio.sleep(0.2)
            else:
                print("üö® ÊíûÁâÜÔºåÂÅúÊ≠¢")
                break

    async def turn_left(self):
        idx = self.order.index(self.facing)
        self.facing = self.order[(idx + 1) % 4]
        self.draw_robot() # This is now a synchronous call
        await asyncio.sleep(0.2)

# --- Main application startup sequence ---
async def main_application_start():
    # Step 1: Preload all robot images. This must complete before animation starts.
    await preload_robot_images() 
    
    # Step 2: Initialize the robot AFTER images are (hopefully) loaded
    global robot
    robot = AnimatedRobot(1, 1)

    # Step 3: Start the patrol animation
    asyncio.create_task(patrol())

# --- Define patrol function ---
async def patrol():
    for _ in range(4):
        await robot.move(9)
        await robot.turn_left()
    print("üö© Â∑°ÈÇèÂÆåÊàêÔºÅ")

# Kick off the main application startup
asyncio.create_task(main_application_start())